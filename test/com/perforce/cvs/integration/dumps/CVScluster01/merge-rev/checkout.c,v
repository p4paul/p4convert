head	1.168;
access;
symbols
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_9:1.50.0.2
	OPENBSD_3_9_BASE:1.50
	OPENBSD_4_0:1.66.0.2
	OPENBSD_4_0_BASE:1.66
	OPENBSD_4_1:1.92.0.2
	OPENBSD_4_1_BASE:1.92
	OPENBSD_4_2:1.99.0.2
	OPENBSD_4_2_BASE:1.99
	OPENBSD_4_3:1.141.0.2
	OPENBSD_4_3_BASE:1.141
	OPENBSD_4_4:1.156.0.2
	OPENBSD_4_4_BASE:1.156
	OPENBSD_4_5:1.160.0.2
	OPENBSD_4_5_BASE:1.160
	OPENBSD_4_6:1.165.0.4
	OPENBSD_4_6_BASE:1.165
	OPENBSD_4_7:1.165.0.2
	OPENBSD_4_7_BASE:1.165
	OPENBSD_4_8:1.167.0.2
	OPENBSD_4_8_BASE:1.167
	OPENBSD_4_9:1.167.0.4
	OPENBSD_4_9_BASE:1.167
	OPENBSD_5_0:1.167.0.6
	OPENBSD_5_0_BASE:1.167
	OPENBSD_5_1:1.168.0.2
	OPENBSD_5_1_BASE:1.168
	OPENBSD_5_2:1.168.0.4
	OPENBSD_5_2_BASE:1.168
	OPENBSD_5_3:1.168.0.6
	OPENBSD_5_3_BASE:1.168
	OPENBSD_5_4:1.168.0.8
	OPENBSD_5_4_BASE:1.168
	OPENBSD_5_5:1.168.0.12
	OPENBSD_5_5_BASE:1.168
	OpenCVS:1.1.0.1
	OpenCVS_0_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.168
date	2011.12.27.13.59.01;	author nicm;	state Exp;
branches;
next	1.167;

1.167
date	2010.07.30.21.47.18;	author ray;	state Exp;
branches;
next	1.166;

1.166
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.165;

1.165
date	2009.06.21.20.23.01;	author sthen;	state Exp;
branches;
next	1.164;

1.164
date	2009.04.06.06.45.56;	author joris;	state Exp;
branches;
next	1.163;

1.163
date	2009.03.27.07.28.57;	author joris;	state Exp;
branches;
next	1.162;

1.162
date	2009.03.25.21.50.33;	author joris;	state Exp;
branches;
next	1.161;

1.161
date	2009.03.18.09.14.09;	author joris;	state Exp;
branches;
next	1.160;

1.160
date	2009.02.23.21.32.08;	author joris;	state Exp;
branches;
next	1.159;

1.159
date	2009.02.21.14.50.53;	author joris;	state Exp;
branches;
next	1.158;

1.158
date	2009.02.21.13.44.18;	author joris;	state Exp;
branches;
next	1.157;

1.157
date	2009.01.28.17.40.13;	author pyr;	state Exp;
branches;
next	1.156;

1.156
date	2008.07.08.12.29.58;	author joris;	state Exp;
branches;
next	1.155;

1.155
date	2008.06.14.04.34.08;	author tobias;	state Exp;
branches;
next	1.154;

1.154
date	2008.06.14.03.58.29;	author tobias;	state Exp;
branches;
next	1.153;

1.153
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.152;

1.152
date	2008.06.12.16.55.48;	author tobias;	state Exp;
branches;
next	1.151;

1.151
date	2008.06.12.07.16.14;	author joris;	state Exp;
branches;
next	1.150;

1.150
date	2008.06.11.21.24.50;	author joris;	state Exp;
branches;
next	1.149;

1.149
date	2008.06.11.02.19.13;	author tobias;	state Exp;
branches;
next	1.148;

1.148
date	2008.06.10.20.30.17;	author joris;	state Exp;
branches;
next	1.147;

1.147
date	2008.06.10.01.00.34;	author joris;	state Exp;
branches;
next	1.146;

1.146
date	2008.06.08.21.48.56;	author joris;	state Exp;
branches;
next	1.145;

1.145
date	2008.06.08.03.03.07;	author tobias;	state Exp;
branches;
next	1.144;

1.144
date	2008.05.22.15.45.01;	author tobias;	state Exp;
branches;
next	1.143;

1.143
date	2008.03.09.03.14.52;	author joris;	state Exp;
branches;
next	1.142;

1.142
date	2008.03.08.20.26.34;	author joris;	state Exp;
branches;
next	1.141;

1.141
date	2008.02.29.21.43.57;	author joris;	state Exp;
branches;
next	1.140;

1.140
date	2008.02.27.22.34.04;	author joris;	state Exp;
branches;
next	1.139;

1.139
date	2008.02.24.20.04.05;	author tobias;	state Exp;
branches;
next	1.138;

1.138
date	2008.02.10.14.08.52;	author xsa;	state Exp;
branches;
next	1.137;

1.137
date	2008.02.10.13.01.08;	author tobias;	state Exp;
branches;
next	1.136;

1.136
date	2008.02.10.10.21.42;	author joris;	state Exp;
branches;
next	1.135;

1.135
date	2008.02.09.20.04.00;	author xsa;	state Exp;
branches;
next	1.134;

1.134
date	2008.02.09.17.01.43;	author tobias;	state Exp;
branches;
next	1.133;

1.133
date	2008.02.09.12.48.23;	author joris;	state Exp;
branches;
next	1.132;

1.132
date	2008.02.09.12.20.33;	author tobias;	state Exp;
branches;
next	1.131;

1.131
date	2008.02.09.11.17.02;	author tobias;	state Exp;
branches;
next	1.130;

1.130
date	2008.02.07.07.50.00;	author xsa;	state Exp;
branches;
next	1.129;

1.129
date	2008.02.06.22.43.22;	author joris;	state Exp;
branches;
next	1.128;

1.128
date	2008.02.04.22.36.40;	author joris;	state Exp;
branches;
next	1.127;

1.127
date	2008.02.04.21.29.17;	author joris;	state Exp;
branches;
next	1.126;

1.126
date	2008.02.04.19.08.32;	author joris;	state Exp;
branches;
next	1.125;

1.125
date	2008.02.04.15.07.32;	author tobias;	state Exp;
branches;
next	1.124;

1.124
date	2008.02.03.23.34.41;	author joris;	state Exp;
branches;
next	1.123;

1.123
date	2008.02.03.22.50.28;	author joris;	state Exp;
branches;
next	1.122;

1.122
date	2008.02.03.20.01.37;	author joris;	state Exp;
branches;
next	1.121;

1.121
date	2008.02.03.19.57.44;	author joris;	state Exp;
branches;
next	1.120;

1.120
date	2008.02.03.18.42.32;	author joris;	state Exp;
branches;
next	1.119;

1.119
date	2008.02.03.17.20.14;	author joris;	state Exp;
branches;
next	1.118;

1.118
date	2008.02.03.15.20.10;	author tobias;	state Exp;
branches;
next	1.117;

1.117
date	2008.02.03.15.08.04;	author tobias;	state Exp;
branches;
next	1.116;

1.116
date	2008.02.02.19.32.28;	author joris;	state Exp;
branches;
next	1.115;

1.115
date	2008.01.31.19.51.40;	author xsa;	state Exp;
branches;
next	1.114;

1.114
date	2008.01.31.19.49.05;	author xsa;	state Exp;
branches;
next	1.113;

1.113
date	2008.01.31.19.38.59;	author tobias;	state Exp;
branches;
next	1.112;

1.112
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.111;

1.111
date	2008.01.28.21.35.09;	author tobias;	state Exp;
branches;
next	1.110;

1.110
date	2008.01.28.20.31.07;	author tobias;	state Exp;
branches;
next	1.109;

1.109
date	2008.01.23.09.34.08;	author tobias;	state Exp;
branches;
next	1.108;

1.108
date	2008.01.21.16.36.46;	author tobias;	state Exp;
branches;
next	1.107;

1.107
date	2008.01.10.10.08.22;	author tobias;	state Exp;
branches;
next	1.106;

1.106
date	2008.01.10.09.54.04;	author tobias;	state Exp;
branches;
next	1.105;

1.105
date	2007.09.23.11.19.24;	author joris;	state Exp;
branches;
next	1.104;

1.104
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.103;

1.103
date	2007.09.22.15.30.29;	author tobias;	state Exp;
branches;
next	1.102;

1.102
date	2007.09.09.20.24.06;	author tobias;	state Exp;
branches;
next	1.101;

1.101
date	2007.09.07.23.05.04;	author joris;	state Exp;
branches;
next	1.100;

1.100
date	2007.09.07.19.36.05;	author tobias;	state Exp;
branches;
next	1.99;

1.99
date	2007.07.25.08.45.24;	author xsa;	state Exp;
branches;
next	1.98;

1.98
date	2007.07.18.08.17.27;	author xsa;	state Exp;
branches;
next	1.97;

1.97
date	2007.07.03.13.22.42;	author joris;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.95;

1.95
date	2007.06.27.03.58.16;	author joris;	state Exp;
branches;
next	1.94;

1.94
date	2007.06.18.17.54.13;	author joris;	state Exp;
branches;
next	1.93;

1.93
date	2007.06.01.17.47.47;	author niallo;	state Exp;
branches;
next	1.92;

1.92
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.91;

1.91
date	2007.02.18.10.30.45;	author otto;	state Exp;
branches;
next	1.90;

1.90
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.89;

1.89
date	2007.01.31.21.07.35;	author xsa;	state Exp;
branches;
next	1.88;

1.88
date	2007.01.28.23.39.42;	author joris;	state Exp;
branches;
next	1.87;

1.87
date	2007.01.28.02.04.45;	author joris;	state Exp;
branches;
next	1.86;

1.86
date	2007.01.26.21.59.11;	author otto;	state Exp;
branches;
next	1.85;

1.85
date	2007.01.26.21.48.17;	author xsa;	state Exp;
branches;
next	1.84;

1.84
date	2007.01.26.11.19.44;	author joris;	state Exp;
branches;
next	1.83;

1.83
date	2007.01.25.23.22.32;	author joris;	state Exp;
branches;
next	1.82;

1.82
date	2007.01.18.08.49.08;	author xsa;	state Exp;
branches;
next	1.81;

1.81
date	2007.01.17.22.39.50;	author thib;	state Exp;
branches;
next	1.80;

1.80
date	2007.01.17.20.38.50;	author xsa;	state Exp;
branches;
next	1.79;

1.79
date	2007.01.17.17.54.50;	author joris;	state Exp;
branches;
next	1.78;

1.78
date	2007.01.16.08.33.46;	author xsa;	state Exp;
branches;
next	1.77;

1.77
date	2007.01.16.08.17.27;	author xsa;	state Exp;
branches;
next	1.76;

1.76
date	2007.01.14.22.20.46;	author xsa;	state Exp;
branches;
next	1.75;

1.75
date	2007.01.14.18.44.55;	author joris;	state Exp;
branches;
next	1.74;

1.74
date	2007.01.13.15.56.15;	author joris;	state Exp;
branches;
next	1.73;

1.73
date	2007.01.13.15.45.59;	author joris;	state Exp;
branches;
next	1.72;

1.72
date	2007.01.13.15.29.34;	author joris;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.12.23.56.11;	author joris;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.12.23.32.01;	author niallo;	state Exp;
branches;
next	1.69;

1.69
date	2007.01.03.22.28.30;	author joris;	state Exp;
branches;
next	1.68;

1.68
date	2007.01.03.20.48.26;	author joris;	state Exp;
branches;
next	1.67;

1.67
date	2006.12.22.11.51.50;	author xsa;	state Exp;
branches;
next	1.66;

1.66
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2006.07.01.20.30.46;	author reyk;	state Exp;
branches;
next	1.64;

1.64
date	2006.06.19.05.05.17;	author joris;	state Exp;
branches;
next	1.63;

1.63
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2006.06.14.20.28.53;	author joris;	state Exp;
branches;
next	1.61;

1.61
date	2006.06.06.06.58.46;	author xsa;	state Exp;
branches;
next	1.60;

1.60
date	2006.06.03.19.07.13;	author joris;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.31.22.25.59;	author joris;	state Exp;
branches;
next	1.58;

1.58
date	2006.05.28.01.24.28;	author joris;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.27.16.10.01;	author joris;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.27.15.14.27;	author joris;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.27.05.59.32;	author joris;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.27.05.20.25;	author joris;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.27.03.30.30;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.24.13.34.27;	author ray;	state Exp;
branches;
next	1.50;

1.50
date	2006.01.31.13.55.20;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2006.01.30.17.58.47;	author xsa;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.27.12.56.28;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2006.01.27.12.45.21;	author xsa;	state Exp;
branches;
next	1.46;

1.46
date	2006.01.27.10.53.23;	author xsa;	state Exp;
branches;
next	1.45;

1.45
date	2006.01.25.12.16.13;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.30.17.51.01;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.03.01.02.08;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.15.17.01.10;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.24.17.48.05;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.08.08.54.43;	author joris;	state Exp;
branches;
next	1.36;

1.36
date	2005.07.08.08.24.09;	author joris;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.34;

1.34
date	2005.06.28.08.54.54;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2005.06.13.07.40.39;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.06.09.09.01.50;	author xsa;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.09.07.24.39;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2005.06.07.15.34.24;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2005.06.07.15.13.25;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.31.08.58.47;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.31.08.26.40;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.30.07.39.21;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.29.17.48.44;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.26.03.07.20;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.24.20.04.43;	author joris;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.23.17.30.35;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.20.18.26.49;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.20.05.13.44;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.22.22.12.00;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.14.01.11.51;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.26.16.05.13;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.12.21.03.46;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.06.13.08.39;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.03.04.56.27;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.30.18.14.07;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.30.01.49.22;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.29.18.32.45;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.28.02.01.29;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.26.17.30.30;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;



desc
@@


1.168
log
@Move some global variables/statics to locals, from Michael W
Bombardieri.
@
text
@/*	$OpenBSD: checkout.c,v 1.167 2010/07/30 21:47:18 ray Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/dirent.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "cvs.h"
#include "diff.h"
#include "remote.h"

static void checkout_check_repository(int, char **);
static int checkout_classify(const char *, const char *);
static void checkout_repository(const char *, const char *);

extern int print_stdout;
extern int prune_dirs;
extern int build_dirs;

static int flags = CR_REPO | CR_RECURSE_DIRS;
static int Aflag = 0;
static char *dflag = NULL;
static char *koptstr = NULL;
static char *dateflag = NULL;

static int nflag = 0;

char *checkout_target_dir = NULL;

time_t cvs_specified_date = -1;
time_t cvs_directory_date = -1;
int disable_fast_checkout = 0;

struct cvs_cmd cvs_cmd_checkout = {
	CVS_OP_CHECKOUT, CVS_USE_WDIR, "checkout",
	{ "co", "get" },
	"Checkout a working copy of a repository",
	"[-AcflNnPpRs] [-D date | -r tag] [-d dir] [-j rev] [-k mode] "
	"[-t id] module ...",
	"AcD:d:fj:k:lNnPpRr:st:",
	NULL,
	cvs_checkout
};

struct cvs_cmd cvs_cmd_export = {
	CVS_OP_EXPORT, CVS_USE_WDIR, "export",
	{ "exp", "ex" },
	"Export sources from CVS, similar to checkout",
	"[-flNnR] [-d dir] [-k mode] -D date | -r rev module ...",
	"D:d:k:flNnRr:",
	NULL,
	cvs_export
};

int
cvs_checkout(int argc, char **argv)
{
	int ch;

	while ((ch = getopt(argc, argv, cvs_cmd_checkout.cmd_opts)) != -1) {
		switch (ch) {
		case 'A':
			Aflag = 1;
			if (koptstr == NULL)
				reset_option = 1;
			if (cvs_specified_tag == NULL)
				reset_tag = 1;
			break;
		case 'c':
			cvs_modules_list();
			exit(0);
		case 'D':
			dateflag = optarg;
			if ((cvs_specified_date = date_parse(dateflag)) == -1)
				fatal("invalid date: %s", dateflag);
			reset_tag = 0;
			break;
		case 'd':
			if (dflag != NULL)
				fatal("-d specified two or more times");
			dflag = optarg;
			checkout_target_dir = dflag;

			if (cvs_server_active == 1)
				disable_fast_checkout = 1;
			break;
		case 'j':
			if (cvs_join_rev1 == NULL)
				cvs_join_rev1 = optarg;
			else if (cvs_join_rev2 == NULL)
				cvs_join_rev2 = optarg;
			else
				fatal("too many -j options");
			break;
		case 'k':
			reset_option = 0;
			koptstr = optarg;
			kflag = rcs_kflag_get(koptstr);
			if (RCS_KWEXP_INVAL(kflag)) {
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
				fatal("%s", cvs_cmd_checkout.cmd_synopsis);
			}
			break;
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'N':
			break;
		case 'n':
			nflag = 1;
			break;
		case 'P':
			prune_dirs = 1;
			break;
		case 'p':
			cmdp->cmd_flags &= ~CVS_USE_WDIR;
			print_stdout = 1;
			cvs_noexec = 1;
			nflag = 1;
			break;
		case 'R':
			flags |= CR_RECURSE_DIRS;
			break;
		case 'r':
			reset_tag = 0;
			cvs_specified_tag = optarg;
			break;
		default:
			fatal("%s", cvs_cmd_checkout.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	if (argc == 0)
		fatal("%s", cvs_cmd_checkout.cmd_synopsis);

	if (cvs_server_active == 1 && disable_fast_checkout != 1) {
		cmdp->cmd_flags &= ~CVS_USE_WDIR;
		cvs_noexec = 1;
	}

	checkout_check_repository(argc, argv);

	if (cvs_server_active == 1 && disable_fast_checkout != 1)
		cvs_noexec = 0;

	return (0);
}

int
cvs_export(int argc, char **argv)
{
	int ch;

	prune_dirs = 1;

	while ((ch = getopt(argc, argv, cvs_cmd_export.cmd_opts)) != -1) {
		switch (ch) {
		case 'd':
			if (dflag != NULL)
				fatal("-d specified two or more times");
			dflag = optarg;
			checkout_target_dir = dflag;

			if (cvs_server_active == 1)
				disable_fast_checkout = 1;
			break;
		case 'k':
			koptstr = optarg;
			kflag = rcs_kflag_get(koptstr);
			if (RCS_KWEXP_INVAL(kflag)) {
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
				fatal("%s", cvs_cmd_export.cmd_synopsis);
			}
			break;
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'N':
			break;
		case 'R':
			flags |= CR_RECURSE_DIRS;
			break;
		case 'r':
			cvs_specified_tag = optarg;
			break;
		default:
			fatal("%s", cvs_cmd_export.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	if (cvs_specified_tag == NULL)
		fatal("must specify a tag or date");

	if (argc == 0)
		fatal("%s", cvs_cmd_export.cmd_synopsis);

	checkout_check_repository(argc, argv);

	return (0);
}

static void
checkout_check_repository(int argc, char **argv)
{
	int i;
	char *wdir, *d;
	struct cvs_recursion cr;
	struct module_checkout *mc;
	struct cvs_ignpat *ip;
	struct cvs_filelist *fl, *nxt;
	char repo[MAXPATHLEN], fpath[MAXPATHLEN], *f[1];

	build_dirs = print_stdout ? 0 : 1;

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_connect_to_server();

		if (cvs_specified_tag != NULL)
			cvs_client_send_request("Argument -r%s",
			    cvs_specified_tag);
		if (Aflag)
			cvs_client_send_request("Argument -A");

		if (dateflag != NULL)
			cvs_client_send_request("Argument -D%s", dateflag);

		if (kflag)
			cvs_client_send_request("Argument -k%s", koptstr);

		if (dflag != NULL)
			cvs_client_send_request("Argument -d%s", dflag);

		if (!(flags & CR_RECURSE_DIRS))
			cvs_client_send_request("Argument -l");

		if (cvs_cmdop == CVS_OP_CHECKOUT && prune_dirs == 1)
			cvs_client_send_request("Argument -P");

		if (print_stdout == 1)
			cvs_client_send_request("Argument -p");

		if (nflag == 1)
			cvs_client_send_request("Argument -n");

		cr.enterdir = NULL;
		cr.leavedir = NULL;
		if (print_stdout)
			cr.fileproc = NULL;
		else
			cr.fileproc = cvs_client_sendfile;

		flags &= ~CR_REPO;
		cr.flags = flags;

		if (cvs_cmdop != CVS_OP_EXPORT)
			cvs_file_run(argc, argv, &cr);

		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");

		cvs_client_send_request("%s",
		    (cvs_cmdop == CVS_OP_CHECKOUT) ? "co" : "export");

		cvs_client_get_responses();

		return;
	}

	for (i = 0; i < argc; i++) {
		mc = cvs_module_lookup(argv[i]);
		current_module = mc;

		RB_FOREACH(fl, cvs_flisthead, &(mc->mc_ignores))
			cvs_file_ignore(fl->file_path, &checkout_ign_pats);

		RB_FOREACH(fl, cvs_flisthead, &(mc->mc_modules)) {
			module_repo_root = NULL;

			(void)xsnprintf(repo, sizeof(repo), "%s/%s",
			    current_cvsroot->cr_dir, fl->file_path);

			if (!(mc->mc_flags & MODULE_ALIAS) || dflag != NULL)
				module_repo_root = xstrdup(fl->file_path);

			if (mc->mc_flags & MODULE_NORECURSE)
				flags &= ~CR_RECURSE_DIRS;

			if (dflag != NULL)
				wdir = dflag;
			else if (mc->mc_flags & MODULE_ALIAS)
				wdir = fl->file_path;
			else
				wdir = mc->mc_name;

			switch (checkout_classify(repo, fl->file_path)) {
			case CVS_FILE:
				cr.fileproc = cvs_update_local;
				cr.flags = flags;

				if (!(mc->mc_flags & MODULE_ALIAS)) {
					module_repo_root =
					    xstrdup(dirname(fl->file_path));
					d = wdir;
					(void)xsnprintf(fpath, sizeof(fpath),
					    "%s/%s", d,
					    basename(fl->file_path));
				} else {
					d = dirname(wdir);
					strlcpy(fpath, fl->file_path,
					    sizeof(fpath));
				}

				if (build_dirs == 1)
					cvs_mkpath(d, cvs_specified_tag);

				f[0] = fpath;
				cvs_file_run(1, f, &cr);
				break;
			case CVS_DIR:
				if (build_dirs == 1)
					cvs_mkpath(wdir, cvs_specified_tag);
				checkout_repository(repo, wdir);
				break;
			default:
				break;
			}

			if (nflag != 1 && mc->mc_prog != NULL &&
			    mc->mc_flags & MODULE_RUN_ON_CHECKOUT)
				cvs_exec(mc->mc_prog, NULL, 0);

			if (module_repo_root != NULL)
				xfree(module_repo_root);
		}

		if (mc->mc_canfree == 1) {
			for (fl = RB_MIN(cvs_flisthead, &(mc->mc_modules));
			    fl != NULL; fl = nxt) {
				nxt = RB_NEXT(cvs_flisthead,
				    &(mc->mc_modules), fl);
				RB_REMOVE(cvs_flisthead,
				    &(mc->mc_modules), fl);
				xfree(fl->file_path);
				xfree(fl);
			}
		}

		while ((ip = TAILQ_FIRST(&checkout_ign_pats)) != NULL) {
			TAILQ_REMOVE(&checkout_ign_pats, ip, ip_list);
			xfree(ip);
		}

		xfree(mc);
	}
}

static int
checkout_classify(const char *repo, const char *arg)
{
	char *d, *f, fpath[MAXPATHLEN];
	struct stat sb;

	if (stat(repo, &sb) == 0) {
		if (S_ISDIR(sb.st_mode))
			return CVS_DIR;
	}

	d = dirname(repo);
	f = basename(repo);

	(void)xsnprintf(fpath, sizeof(fpath), "%s/%s%s", d, f, RCS_FILE_EXT);
	if (stat(fpath, &sb) == 0) {
		if (!S_ISREG(sb.st_mode)) {
			cvs_log(LP_ERR, "ignoring %s: not a regular file", arg);
			return 0;
		}
		return CVS_FILE;
	}

	(void)xsnprintf(fpath, sizeof(fpath), "%s/%s/%s%s",
	    d, CVS_PATH_ATTIC, f, RCS_FILE_EXT);
	if (stat(fpath, &sb) == 0) {
		if (!S_ISREG(sb.st_mode)) {
			cvs_log(LP_ERR, "ignoring %s: not a regular file", arg);
			return 0;
		}
		return CVS_FILE;
	}

	cvs_log(LP_ERR, "cannot find module `%s' - ignored", arg);
	return 0;
}

static void
checkout_repository(const char *repobase, const char *wdbase)
{
	struct cvs_flisthead fl, dl;
	struct cvs_recursion cr;

	RB_INIT(&fl);
	RB_INIT(&dl);

	cvs_history_add((cvs_cmdop == CVS_OP_CHECKOUT) ?
	    CVS_HISTORY_CHECKOUT : CVS_HISTORY_EXPORT, NULL, wdbase);

	if (print_stdout) {
		cr.enterdir = NULL;
		cr.leavedir = NULL;
	} else {
		cr.enterdir = cvs_update_enterdir;
		if (cvs_server_active == 1) {
			if (disable_fast_checkout != 1)
				cr.leavedir = NULL;
			else
				cr.leavedir = cvs_update_leavedir;
		} else {
			cr.leavedir = prune_dirs ? cvs_update_leavedir : NULL;
		}
	}
	cr.fileproc = cvs_update_local;
	cr.flags = flags;

	cvs_repository_lock(repobase, 0);
	cvs_repository_getdir(repobase, wdbase, &fl, &dl,
	    flags & CR_RECURSE_DIRS ? REPOSITORY_DODIRS : 0);

	cvs_file_walklist(&fl, &cr);
	cvs_file_freelist(&fl);

	cvs_repository_unlock(repobase);

	cvs_file_walklist(&dl, &cr);
	cvs_file_freelist(&dl);
}

void
cvs_checkout_file(struct cvs_file *cf, RCSNUM *rnum, char *tag, int co_flags)
{
	BUF *bp;
	mode_t mode;
	int cf_kflag, exists;
	time_t rcstime;
	CVSENTRIES *ent;
	struct timeval tv[2];
	struct tm datetm;
	char *entry, *tosend;
	char kbuf[8], sticky[CVS_REV_BUFSZ], rev[CVS_REV_BUFSZ];
	char timebuf[CVS_TIME_BUFSZ], tbuf[CVS_TIME_BUFSZ];
	static char lastwd[MAXPATHLEN];

	exists = 0;
	tosend = NULL;

	if (!(co_flags & CO_REMOVE))
		rcsnum_tostr(rnum, rev, sizeof(rev));
	else
		rev[0] = '\0';

	cvs_log(LP_TRACE, "cvs_checkout_file(%s, %s, %d) -> %s",
	    cf->file_path, rev, co_flags,
	    (cvs_server_active) ? "to client" : "to disk");

	if (co_flags & CO_DUMP) {
		rcs_rev_write_fd(cf->file_rcs, rnum, STDOUT_FILENO, 0);
		return;
	}

	if (cvs_server_active == 0) {
		(void)unlink(cf->file_path);

		if (!(co_flags & CO_MERGE)) {
			if (cf->file_flags & FILE_ON_DISK) {
				exists = 1;
				(void)close(cf->fd);
			}

			cf->fd = open(cf->file_path,
			    O_CREAT | O_RDWR | O_TRUNC);
			if (cf->fd == -1)
				fatal("cvs_checkout_file: open: %s",
				    strerror(errno));

			rcs_rev_write_fd(cf->file_rcs, rnum, cf->fd, 0);
			cf->file_flags |= FILE_ON_DISK;
		} else {
			cvs_merge_file(cf, (cvs_join_rev1 == NULL));
		}

		mode = cf->file_rcs->rf_mode;
		mode |= S_IWUSR;

		if (fchmod(cf->fd, mode) == -1)
			fatal("cvs_checkout_file: fchmod: %s", strerror(errno));

		if ((exists == 0) && (cf->file_ent == NULL) &&
		    !(co_flags & CO_MERGE))
			rcstime = rcs_rev_getdate(cf->file_rcs, rnum);
		else
			time(&rcstime);

		tv[0].tv_sec = rcstime;
		tv[0].tv_usec = 0;
		tv[1] = tv[0];
		if (futimes(cf->fd, tv) == -1)
			fatal("cvs_checkout_file: futimes: %s",
			    strerror(errno));
	} else {
		time(&rcstime);
	}

	gmtime_r(&rcstime, &datetm);
	asctime_r(&datetm, tbuf);
	tbuf[strcspn(tbuf, "\n")] = '\0';

	if (co_flags & CO_MERGE) {
		(void)xsnprintf(timebuf, sizeof(timebuf), "Result of merge+%s",
		    tbuf);
	} else {
		strlcpy(timebuf, tbuf, sizeof(timebuf));
	}

	if (reset_tag) {
		sticky[0] = '\0';
	} else if (co_flags & CO_SETSTICKY)
		if (tag != NULL)
			(void)xsnprintf(sticky, sizeof(sticky), "T%s", tag);
		else if (cvs_specified_date != -1) {
			gmtime_r(&cvs_specified_date, &datetm);
			(void)strftime(sticky, sizeof(sticky),
			    "D"CVS_DATE_FMT, &datetm);
		} else if (cvs_directory_date != -1) {
			gmtime_r(&cvs_directory_date, &datetm);
			(void)strftime(sticky, sizeof(sticky),
			    "D"CVS_DATE_FMT, &datetm);
		} else
			(void)xsnprintf(sticky, sizeof(sticky), "T%s", rev);
	else if (cf->file_ent != NULL && cf->file_ent->ce_tag != NULL)
		(void)xsnprintf(sticky, sizeof(sticky), "T%s",
		    cf->file_ent->ce_tag);
	else
		sticky[0] = '\0';

	kbuf[0] = '\0';
	if (cf->file_rcs != NULL && cf->file_rcs->rf_expand != NULL) {
		cf_kflag = rcs_kflag_get(cf->file_rcs->rf_expand);
		if (kflag || cf_kflag != RCS_KWEXP_DEFAULT)
			(void)xsnprintf(kbuf, sizeof(kbuf),
			    "-k%s", cf->file_rcs->rf_expand);
	} else if (!reset_option && cf->file_ent != NULL) {
		if (cf->file_ent->ce_opts != NULL)
			strlcpy(kbuf, cf->file_ent->ce_opts, sizeof(kbuf));
	}

	entry = xmalloc(CVS_ENT_MAXLINELEN);
	cvs_ent_line_str(cf->file_name, rev, timebuf, kbuf, sticky, 0, 0,
	    entry, CVS_ENT_MAXLINELEN);

	if (cvs_server_active == 0) {
		if (!(co_flags & CO_REMOVE) && cvs_cmdop != CVS_OP_EXPORT) {
			ent = cvs_ent_open(cf->file_wd);
			cvs_ent_add(ent, entry);
			cf->file_ent = cvs_ent_parse(entry);
		}
	} else {
		if (co_flags & CO_MERGE) {
			(void)unlink(cf->file_path);
			cvs_merge_file(cf, (cvs_join_rev1 == NULL));
			tosend = cf->file_path;
		}

		/*
		 * If this file has a tag, push out the Directory with the
		 * tag to the client. Except when this file was explicitly
		 * specified on the command line.
		 */
		if (tag != NULL && strcmp(cf->file_wd, lastwd) &&
		    !(cf->file_flags & FILE_USER_SUPPLIED)) {
			strlcpy(lastwd, cf->file_wd, MAXPATHLEN);
			cvs_server_set_sticky(cf->file_wd, sticky);
		}

		if (co_flags & CO_COMMIT)
			cvs_server_update_entry("Updated", cf);
		else if (co_flags & CO_MERGE)
			cvs_server_update_entry("Merged", cf);
		else if (co_flags & CO_REMOVE)
			cvs_server_update_entry("Removed", cf);
		else
			cvs_server_update_entry("Updated", cf);

		if (!(co_flags & CO_REMOVE)) {
			cvs_remote_output(entry);

			if (!(co_flags & CO_MERGE)) {
				mode = cf->file_rcs->rf_mode;
				mode |= S_IWUSR;
				bp = rcs_rev_getbuf(cf->file_rcs, rnum, 0);
				cvs_remote_send_file_buf(cf->file_path,
				    bp, mode);
			} else {
				cvs_remote_send_file(tosend, cf->fd);
			}
		}
	}

	xfree(entry);
}
@


1.167
log
@Check date_parse return values.

OK xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.166 2010/07/23 21:46:05 ray Exp $	*/
a50 1
static char lastwd[MAXPATHLEN];
d480 1
@


1.166
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.165 2009/06/21 20:23:01 sthen Exp $	*/
d98 2
a99 1
			cvs_specified_date = date_parse(dateflag);
@


1.165
log
@Use correct synopses for checkout and export when an invalid -k option
is specified. From Dawe in user/6177.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.164 2009/04/06 06:45:56 joris Exp $	*/
d98 1
a98 1
			cvs_specified_date = cvs_date_parse(dateflag);
@


1.164
log
@make sure we handle allowed options in cvs_export() instead
of ignoring them, even if they are just stubs.
unbreaks export with gnu cvs clients.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.163 2009/03/27 07:28:57 joris Exp $	*/
d125 1
a125 1
				fatal("%s", cvs_cmd_add.cmd_synopsis);
d200 1
a200 1
				fatal("%s", cvs_cmd_add.cmd_synopsis);
@


1.163
log
@make sure that when we try to send a Set-sticky to the client,
we only do so if the file we're checking out was not supplied
on the command-line. Otherwise we'll end up setting CVS/Tag
for the entire directory instead of slapping a sticky tag
only on the file supplied.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.162 2009/03/25 21:50:33 joris Exp $	*/
d205 2
@


1.162
log
@switch our file and directory lists to RB trees (see tree(3)),
so we can benefit from faster lookup times while recursing.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.161 2009/03/18 09:14:09 joris Exp $	*/
d601 2
a602 1
		 * tag to the client. 
d604 2
a605 1
		if (tag != NULL && strcmp(cf->file_wd, lastwd)) {
@


1.161
log
@be carefull when trying to access cf->file_rcs in cvs_checkout_file()
as it could be NULL under certain conditions.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.160 2009/02/23 21:32:08 joris Exp $	*/
d302 1
a302 1
		TAILQ_FOREACH(fl, &(mc->mc_ignores), flist)
d305 1
a305 1
		TAILQ_FOREACH(fl, &(mc->mc_modules), flist) {
d366 6
a371 4
			for (fl = TAILQ_FIRST(&(mc->mc_modules));
			    fl != TAILQ_END(&(mc->mc_modules)); fl = nxt) {
				nxt = TAILQ_NEXT(fl, flist);
				TAILQ_REMOVE(&(mc->mc_modules), fl, flist);
d429 2
a430 2
	TAILQ_INIT(&fl);
	TAILQ_INIT(&dl);
@


1.160
log
@we no longer push out Set-sticky to the client when writing
our Tag file on the server or in cvs_mkpath(), this caused
problems for the "fast checkout" mechanism when a tag was supplied.

instead, write out any directory sticky tag when we are checking
out a file in that directory, this way we can use our "fast checkout"
mechanism (no /tmp required) even for -r and -d without breaking
working copies because they were missing CVS/Tag files.

"looks good" tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.159 2009/02/21 14:50:53 joris Exp $	*/
d570 1
a570 1
	if (cf->file_rcs->rf_expand != NULL) {
@


1.159
log
@use FILE_ON_DISK flags when we need to verify if a file
exists in the working copy or not instead of checking fd being -1
since this can differ in server or local mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.158 2009/02/21 13:44:18 joris Exp $	*/
d51 1
d595 9
@


1.158
log
@use file_flags for 2 more reasons:
- mark a file as being inside the Attic/
- mark a file as existing in the working copy
  (both in local and remote mode)

this way we no longer will need to check if cf->fd == -1 and
think about wether or not we are in local or remote mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.157 2009/01/28 17:40:13 pyr Exp $	*/
d497 1
a497 1
			if (cf->fd != -1) {
d509 1
@


1.157
log
@enable -d for the export command.
ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.156 2008/07/08 12:29:58 joris Exp $	*/
d451 1
a451 1
	    flags & CR_RECURSE_DIRS ? 1 : 0);
@


1.156
log
@use cf->fd in cvs_remote_sendfile() instead of using a local
variable that is only used once, which is in this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.155 2008/06/14 04:34:08 tobias Exp $	*/
d184 9
@


1.155
log
@Conforming to RCS specification, it is possible but unlikely to encounter
an RCS file which has no head revision set.  Some commands actually can
work with them (log, status) so support these files. Fixes  A LOT of
possible segmentation faults.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.154 2008/06/14 03:58:29 tobias Exp $	*/
d458 1
a458 1
	int cf_kflag, exists, fd;
a583 1
			fd = cf->fd;
d605 1
a605 1
				cvs_remote_send_file(tosend, fd);
@


1.154
log
@Added support for sticky date set in CVS/Tag and CVS/Entries per directory.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.153 2008/06/14 03:19:15 joris Exp $	*/
d472 2
@


1.153
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.152 2008/06/12 16:55:48 tobias Exp $	*/
d54 1
d98 1
d535 3
a537 1
	if (co_flags & CO_SETSTICKY)
d544 4
d550 1
a550 2
	else if (!reset_tag && cf->file_ent != NULL &&
	    cf->file_ent->ce_tag != NULL)
@


1.152
log
@Fixed a memory leak in export noticed by joris.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.151 2008/06/12 07:16:14 joris Exp $	*/
a567 1
			cvs_ent_close(ent, ENT_SYNC);
@


1.151
log
@completely kill the need for TMP_DIR when running checkout,
which gives us better performance among other things.

this is however disabled in a few cases:
1) whenever you run checkout over an existing tree (which acts as update)
2) whenever you specify -d or a module alias

we're planning on enabling this behaviour for case 2 in the future.

anoncvs sysadmins now love us even more.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.150 2008/06/11 21:24:50 joris Exp $	*/
a569 1
			xfree(entry);
a589 1
			xfree(entry);
d602 2
@


1.150
log
@always enter cvs_update_leavedir()
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.149 2008/06/11 02:19:13 tobias Exp $	*/
d52 1
d54 1
d103 3
d160 5
d167 3
d426 8
a433 1
		cr.leavedir = cvs_update_leavedir;
d454 1
d461 1
a461 2
	char *tosend;
	char template[MAXPATHLEN], *entry;
a593 6
				(void)xsnprintf(template, MAXPATHLEN,
				    "%s/checkout.XXXXXXXXXX", cvs_tmpdir);

				fd = rcs_rev_write_stmp(cf->file_rcs, rnum,
				    template, 0);

d596 5
a600 17

				if (fchmod(fd, mode) == -1) {
					cvs_log(LP_ERR,
					    "failed to set mode for %s",
					    cf->file_path);
				}

				tosend = template;
			}

			cvs_remote_send_file(tosend, fd);

			if (!(co_flags & CO_MERGE)) {
				close(fd);
				(void)unlink(template);
				cvs_worklist_run(&temp_files,
				    cvs_worklist_unlink);
@


1.149
log
@Avoid possible NULL pointer dereferences by using reentrant versions
of time functions.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.148 2008/06/10 20:30:17 joris Exp $	*/
d413 1
a413 1
		cr.leavedir = prune_dirs ? cvs_update_leavedir : NULL;
@


1.148
log
@properly inherit file permissions.

reported & tested by phessler@@
input otto@@ deraadt@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.147 2008/06/10 01:00:34 joris Exp $	*/
d28 1
d439 1
a439 1
	struct tm *datetm;
d502 2
a503 1
	asctime_r(gmtime(&rcstime), tbuf);
d517 1
a517 1
			datetm = gmtime(&cvs_specified_date);
d519 1
a519 1
			    "D"CVS_DATE_FMT, datetm);
@


1.147
log
@New trigger framework that allows us to run the required scripts
defined in CVSROOT/commitinfo and CVSROOT/loginfo and so on.

This enables the use of log_accum2 and all that other nice stuff we like.

This was mostly written by Jonathan Armani with help from tobias@@ and myself.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.146 2008/06/08 21:48:56 joris Exp $	*/
d433 1
d479 4
a482 1
		if (fchmod(cf->fd, 0644) == -1)
d577 10
@


1.146
log
@simplification from igor
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.145 2008/06/08 03:03:07 tobias Exp $	*/
d333 1
a333 1
				cvs_exec(mc->mc_prog);
@


1.145
log
@Avoid memory leaks in directory tag handling by always allocating and
always freeing dirtag.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.144 2008/05/22 15:45:01 tobias Exp $	*/
a565 1
		}
a566 1
		if (!(co_flags & CO_REMOVE)) {
@


1.144
log
@expension -> expansion

ok joris, xsa (quite some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.143 2008/03/09 03:14:52 joris Exp $	*/
a270 2

	cvs_directory_tag = cvs_specified_tag;
@


1.143
log
@proper repository locking:
- all read operations now look for a lock, and wait if present but never
  try to lock the tree themselfs anymore.
- all write operations lock the tree where needed.
- commit locks all relevant directories before even attempting to start.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.142 2008/03/08 20:26:34 joris Exp $	*/
d115 1
a115 1
				    "invalid RCS keyword expension mode");
d173 1
a173 1
				    "invalid RCS keyword expension mode");
@


1.142
log
@add checkout/update -j support.
still has some rough edges.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.141 2008/02/29 21:43:57 joris Exp $	*/
d419 1
a419 1
	cvs_repository_lock(repobase);
@


1.141
log
@handle file permissions and owners properly.
matches what gnu cvs does.

fixes the fact that we couldnt update group writable files.

problem report & diff testing by David Crawshaw.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.140 2008/02/27 22:34:04 joris Exp $	*/
d101 8
d470 1
a470 1
			    O_CREAT | O_WRONLY | O_TRUNC);
d477 1
a477 1
			cvs_merge_file(cf, 1);
d545 1
d551 1
a551 1
			cvs_merge_file(cf, 1);
@


1.140
log
@prevent file races

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.139 2008/02/24 20:04:05 tobias Exp $	*/
d427 1
a427 1
	int cf_kflag, oflags, exists, fd;
d453 2
a455 1
			oflags = O_WRONLY | O_TRUNC;
a458 2
			} else  {
				oflags |= O_CREAT;
d461 2
a462 1
			cf->fd = open(cf->file_path, oflags);
d541 1
@


1.139
log
@Properly handle return value of dirname().

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.138 2008/02/10 14:08:52 xsa Exp $	*/
d427 1
a427 1
	int cf_kflag, oflags, exists;
d543 1
d565 1
a565 1
				rcs_rev_write_stmp(cf->file_rcs, rnum,
d570 1
a570 1
			cvs_remote_send_file(tosend);
d573 1
@


1.138
log
@+ #define CVS_DATE_FMT   "%Y.%m.%d.%H.%M.%S"
...and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.137 2008/02/10 13:01:08 tobias Exp $	*/
d274 2
d280 1
a280 1
				module_repo_root = fl->file_path;
d299 1
a299 1
					    dirname(fl->file_path);
d328 3
@


1.137
log
@Respond with "Updated" instead of "Checked-in" on server-side if a client
committed files, so keywords are expanded properly.

On client-side, we have to be careful about Directory ./ when it comes
to commits, so add a test for CVS_OP_COMMIT.

OK and help from joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.136 2008/02/10 10:21:42 joris Exp $	*/
d500 3
a502 3
                        datetm = gmtime(&cvs_specified_date);
                        strftime(sticky, sizeof(sticky), "D%Y.%m.%d.%H.%M.%S",
                            datetm);
@


1.136
log
@properly initialize cvs_specified_date so we dont end up with
random stuff going on
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.135 2008/02/09 20:04:00 xsa Exp $	*/
d541 1
a541 1
			cvs_server_update_entry("Checked-in", cf);
d554 1
a554 1
		if (!(co_flags & CO_COMMIT) && !(co_flags & CO_REMOVE)) {
@


1.135
log
@Introduce cvs_ent_line_str() - formats CVS/Entries lines.
OK tobias@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.134 2008/02/09 17:01:43 tobias Exp $	*/
d51 1
a51 1
time_t cvs_specified_date;
d499 1
a499 1
		else if (cvs_specified_date != 0) {
@


1.134
log
@Support for checkout -D extended:
Properly write CVS/Tag and CVS/Entries on various combinations of -r and -D.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.133 2008/02/09 12:48:23 joris Exp $	*/
d428 1
a428 1
	char template[MAXPATHLEN], entry[CVS_ENT_MAXLINELEN];
d523 3
a525 2
	(void)xsnprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s/%s/%s/%s",
	    cf->file_name, rev, timebuf, kbuf, sticky);
d532 1
d549 1
a549 1
		if (!(co_flags & CO_REMOVE))
d551 2
@


1.133
log
@remote improvements:

- make sure the client creates the correct CVS/Repository when running
  checkout if there was no -d targetdir specified.
- allow -D to work remotely for both checkout and update.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.132 2008/02/09 12:20:33 tobias Exp $	*/
d426 1
d499 5
a503 1
		else
@


1.132
log
@Get in proper support for checkout/update -A when it comes to keyword
expansion options.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.131 2008/02/09 11:17:02 tobias Exp $	*/
d46 1
d50 1
d92 2
a93 1
			cvs_specified_date = cvs_date_parse(optarg);
d99 1
d218 3
@


1.131
log
@Get in initial support for checkout -D.  Works fine with -r support right
now.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.130 2008/02/07 07:50:00 xsa Exp $	*/
d43 1
d80 5
a84 1
			reset_stickies = 1;
d98 1
d128 1
d212 1
a212 1
		if (reset_stickies == 1)
d493 1
a493 1
	else if (!reset_stickies && cf->file_ent != NULL &&
d506 1
a506 1
	} else if (!reset_stickies && cf->file_ent != NULL) {
@


1.130
log
@exit() needs stdlib.h
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.128 2008/02/04 22:36:40 joris Exp $	*/
d48 2
d84 3
@


1.129
log
@lets do co -c as well (list available modules) and do it in 1/6th of the
lines GNU cvs does it in, without actually fucking up on bad lines,
like gnucvs.

ok tobias@@
@
text
@d26 1
@


1.128
log
@CVSROOT/modules:

correct -i and -o usage

-i runs the program specified on commit
-o runs the program specified on checkout
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.127 2008/02/04 21:29:17 joris Exp $	*/
d78 3
@


1.127
log
@implement -n for checkout:
	"Do not execute programs listed in the CVSROOT/modules file."

ok tobias@@, pleasekeepthingssortedktnx xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.126 2008/02/04 19:08:32 joris Exp $	*/
d301 1
a301 1
			    mc->mc_flags & MODULE_RUN_ON_COMMIT)
@


1.126
log
@more CVSROOT/modules stuff:

- support for -i flag:
	Run "prog" on "cvs commit" from top-level of module.
- fix some memory leaks in modules.c
- pass the line number from cvs_read_config() towards the callbacks
  so its easier to print out where it's going wrong, if it ever does.

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.125 2008/02/04 15:07:32 tobias Exp $	*/
d45 2
d97 3
d107 1
d214 3
d300 1
a300 1
			if (mc->mc_prog != NULL &&
@


1.125
log
@Added -k flag support for all commands which support it.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.124 2008/02/03 23:34:41 joris Exp $	*/
d290 4
@


1.124
log
@shuffle some stuff around so we dont end up doing the same things
twice in cvs_module_lookup() and checkout_check_directory();

allow single files to be ignored with ! as well;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.123 2008/02/03 22:50:28 joris Exp $	*/
d43 1
d81 9
d134 9
d193 3
d386 1
a386 1
	int kflag, oflags, exists;
d472 6
a477 1
	if (cf->file_ent != NULL) {
a479 5
	} else if (cf->file_rcs->rf_expand != NULL) {
		kflag = rcs_kflag_get(cf->file_rcs->rf_expand);
		if (!(kflag & RCS_KWEXP_DEFAULT))
			(void)xsnprintf(kbuf, sizeof(kbuf),
			    "-k%s", cf->file_rcs->rf_expand);
@


1.123
log
@more CVSROOT/module stuff:

- allow more then 1 module to be specified per definition
- respect the "!" sign which means: "hey ignore this dir when checking out"
- non alias definitions can now contain files

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.122 2008/02/03 20:01:37 joris Exp $	*/
d231 2
d234 1
a234 1
				wdir = mc->mc_wdir;
a284 1
		xfree(mc->mc_wdir);
@


1.122
log
@dont forget to send the -d flag to our server as well if it
was specified;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.121 2008/02/03 19:57:44 joris Exp $	*/
d156 1
a156 2
	char *wdir;
	char repo[MAXPATHLEN];
d159 3
d216 2
a217 2
		(void)xsnprintf(repo, sizeof(repo), "%s/%s",
		    current_cvsroot->cr_dir, mc->mc_repo);
d219 3
a221 2
		if (!(mc->mc_flags & MODULE_ALIAS) || dflag != NULL)
			module_repo_root = mc->mc_repo;
d223 44
a266 2
		if (mc->mc_flags & MODULE_NORECURSE)
			flags &= ~CR_RECURSE_DIRS;
d268 9
a276 4
		if (dflag != NULL)
			wdir = dflag;
		else
			wdir = mc->mc_wdir;
d278 3
a280 17
		switch (checkout_classify(repo, mc->mc_repo)) {
		case CVS_FILE:
			cr.fileproc = cvs_update_local;
			cr.flags = flags;

			if (build_dirs == 1)
				cvs_mkpath(dirname(wdir),
				    cvs_specified_tag);
			cvs_file_run(1, &(mc->mc_repo), &cr);
			break;
		case CVS_DIR:
			if (build_dirs == 1)
				cvs_mkpath(wdir, cvs_specified_tag);
			checkout_repository(repo, wdir);
			break;
		default:
			break;
a283 1
		xfree(mc->mc_repo);
d295 2
a296 5
		if (!S_ISDIR(sb.st_mode)) {
			cvs_log(LP_ERR, "ignoring %s: not a directory", arg);
			return 0;
		}
		return CVS_DIR;
@


1.121
log
@respect any -l option that might have been set in CVSROOT/modules;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.120 2008/02/03 18:42:32 joris Exp $	*/
d171 3
@


1.120
log
@with the recent changes for CVSROOT/modules we can now support the
basics of checkout -d. Multiple modules with -d is still "not supported".

example:

$ opencvs -d /cvs co -d kernel_source_3_0 -rOPENBSD_3_0 ksrc

yes, it rocks.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.119 2008/02/03 17:20:14 joris Exp $	*/
d216 3
@


1.119
log
@better CVSROOT/module support, includes remote support and modules
that are not aliases (-a);

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.118 2008/02/03 15:20:10 tobias Exp $	*/
d42 1
d75 5
d156 1
d214 1
a214 1
		if (!(mc->mc_flags & MODULE_ALIAS))
d217 5
d228 1
a228 1
				cvs_mkpath(dirname(mc->mc_wdir),
d234 2
a235 2
				cvs_mkpath(mc->mc_wdir, cvs_specified_tag);
			checkout_repository(repo, mc->mc_wdir);
@


1.118
log
@cvs_update_leavedir is only useful if dirs have to be pruned.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.117 2008/02/03 15:08:04 tobias Exp $	*/
a149 1
	char *module;
d152 1
d201 2
a202 1
		module = cvs_module_lookup(argv[i]);
d205 1
a205 1
		    current_cvsroot->cr_dir, module);
d207 4
a210 1
		switch (checkout_classify(repo, module)) {
d216 3
a218 2
				cvs_mkpath(dirname(module), cvs_specified_tag);
			cvs_file_run(1, &(module), &cr);
d222 2
a223 2
				cvs_mkpath(module, cvs_specified_tag);
			checkout_repository(repo, module);
d228 4
@


1.117
log
@(f)utimes takes sys/time.h
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.116 2008/02/02 19:32:28 joris Exp $	*/
d283 1
a283 1
		cr.leavedir = cvs_update_leavedir;
@


1.116
log
@initial CVSROOT/modules support, only does aliases at the moment (-a).
"modules.c, hurray!" xsa@@, ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.115 2008/01/31 19:51:40 xsa Exp $	*/
d21 1
@


1.115
log
@Make use of CVS_REV_BUFSZ everywhere for `sticky'.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.114 2008/01/31 19:49:05 xsa Exp $	*/
d149 1
d200 2
d203 1
a203 1
		    current_cvsroot->cr_dir, argv[i]);
d205 1
a205 1
		switch (checkout_classify(repo, argv[i])) {
d211 2
a212 2
				cvs_mkpath(dirname(argv[i]), cvs_specified_tag);
			cvs_file_run(1, &(argv[i]), &cr);
d216 2
a217 2
				cvs_mkpath(argv[i], cvs_specified_tag);
			checkout_repository(repo, argv[i]);
@


1.114
log
@Rename `stickytag' variable to `sticky' for consistency with rest of the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.113 2008/01/31 19:38:59 tobias Exp $	*/
d306 1
a306 1
	char kbuf[8], sticky[32], rev[CVS_REV_BUFSZ];
@


1.113
log
@We have to carefully check if a checkout command is run with a valid
directory or file.  When it comes to files, check if there is a file
available ending in ,v or if it is in Attic.  Everything else in invalid.

OK joris@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.112 2008/01/31 10:15:05 tobias Exp $	*/
d306 1
a306 1
	char kbuf[8], stickytag[32], rev[CVS_REV_BUFSZ];
d375 1
a375 2
			(void)xsnprintf(stickytag, sizeof(stickytag), "T%s",
			    tag);
d377 1
a377 2
			(void)xsnprintf(stickytag, sizeof(stickytag), "T%s",
			    rev);
d380 1
a380 1
		(void)xsnprintf(stickytag, sizeof(stickytag), "T%s",
d383 1
a383 1
		stickytag[0] = '\0';
d397 1
a397 1
	    cf->file_name, rev, timebuf, kbuf, stickytag);
@


1.112
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.111 2008/01/28 21:35:09 tobias Exp $	*/
d33 1
a149 1
	struct stat st;
d202 2
a203 11
		if (stat(repo, &st) == -1) {
			/* check if a single file was requested */
			strlcat(repo, RCS_FILE_EXT, MAXPATHLEN);

			if (stat(repo, &st) == -1) {
				cvs_log(LP_ERR,
				    "cannot find module `%s' - ignored",
				    argv[i]);
				continue;
			}

d210 11
d222 10
a231 1
			continue;
d233 2
d236 10
a245 3
		if (build_dirs == 1)
			cvs_mkpath(argv[i], cvs_specified_tag);
		checkout_repository(repo, argv[i]);
d247 13
@


1.111
log
@Actually support checkout's -l.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.110 2008/01/28 20:31:07 tobias Exp $	*/
d42 1
a42 1
	CVS_OP_CHECKOUT, 0, "checkout",
d53 1
a53 1
	CVS_OP_EXPORT, 0, "export",
d81 1
d241 7
a247 2
	cr.enterdir = cvs_update_enterdir;
	cr.leavedir = cvs_update_leavedir;
@


1.110
log
@Properly handle -R -- although it is default, it may be overwritten mit -l
in front of it.

OK joris@@, xsa@@

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.109 2008/01/23 09:34:08 tobias Exp $	*/
d246 2
a247 1
	cvs_repository_getdir(repobase, wdbase, &fl, &dl, 1);
@


1.109
log
@Don't reset the sticky tag of a file in CVS/Entries if it is not requested.

OK niallo@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.108 2008/01/21 16:36:46 tobias Exp $	*/
d85 1
d119 1
@


1.108
log
@Fixed export to be fully functional and compliant to GNU cvs in local and
remote setups.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.107 2008/01/10 10:08:22 tobias Exp $	*/
d338 4
@


1.107
log
@another strcspn() round
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.106 2008/01/10 09:54:04 tobias Exp $	*/
d130 3
d179 2
a180 1
		cvs_file_run(argc, argv, &cr);
d356 1
a356 1
		if (!(co_flags & CO_REMOVE)) {
@


1.106
log
@Our keyword expansion had a big flaw, due to this construction:
if (!(mode & RCS_KWEXP_NONE))

RCS_KWEXP_NONE is defined to 0, so expansion happened always.

Left shifted all RCS_KWEXP defines and looked carefully at hard-coded values
throughout the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.105 2007/09/23 11:19:24 joris Exp $	*/
d318 1
a318 2
	if (tbuf[strlen(tbuf) - 1] == '\n')
		tbuf[strlen(tbuf) - 1] = '\0';
@


1.105
log
@make sure when running update -r on existing files to overwrite
the sticky directory tag with it. since -r gets priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.104 2007/09/22 16:01:22 joris Exp $	*/
d274 1
a274 1
		rcs_rev_write_fd(cf->file_rcs, rnum, STDOUT_FILENO, 1);
d293 1
a293 1
			rcs_rev_write_fd(cf->file_rcs, rnum, cf->fd, 1);
@


1.104
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.103 2007/09/22 15:30:29 tobias Exp $	*/
d252 1
a252 1
cvs_checkout_file(struct cvs_file *cf, RCSNUM *rnum, int co_flags)
d329 1
a329 1
		if (cvs_directory_tag != NULL)
d331 1
a331 1
			    cvs_directory_tag);
@


1.103
log
@Support for checkout with a local repository already in place.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.102 2007/09/09 20:24:06 tobias Exp $	*/
d75 2
d189 2
d265 3
a267 1
	rcsnum_tostr(rnum, rev, sizeof(rev));
d329 1
a329 1
		if (cvs_specified_tag != NULL)
d331 1
a331 1
			    cvs_specified_tag);
@


1.102
log
@Added support for checkout -p with local repository.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.101 2007/09/07 23:05:04 joris Exp $	*/
d166 6
a171 1
		cr.fileproc = NULL;
@


1.101
log
@Sprinkle some magic so checkout/update -p works
in both local and server mode.

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.100 2007/09/07 19:36:05 tobias Exp $	*/
d144 2
d166 1
a166 1
		cr.fileproc = cvs_client_sendfile;
d199 3
a201 1
			cvs_mkpath(dirname(argv[i]), cvs_specified_tag);
d207 2
a208 1
		cvs_mkpath(argv[i], cvs_specified_tag);
a224 1
	build_dirs = 1;
@


1.100
log
@Added support for single file checkout.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.99 2007/07/25 08:45:24 xsa Exp $	*/
d35 1
d78 4
d159 3
d259 1
a259 7
		if (cvs_server_active) {
			cvs_printf("dump file %s to client\n", cf->file_path);
		} else {
			rcs_rev_write_fd(cf->file_rcs, rnum,
			    STDOUT_FILENO, 1);
		}

@


1.99
log
@Correctly handle the export command when writing to history file.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.98 2007/07/18 08:17:27 xsa Exp $	*/
d24 1
d177 15
a191 2
			cvs_log(LP_ERR, "cannot find module `%s' - ignored",
			    argv[i]);
@


1.98
log
@Support -r for the export command.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.97 2007/07/03 13:22:42 joris Exp $	*/
d195 2
a196 1
	cvs_history_add(CVS_HISTORY_CHECKOUT, NULL, wdbase);
@


1.97
log
@Rework the way opencvs works in relation to files in the Attic/:

Previously, files in the 'Attic/' were linked into our filelist as being
'Attic/filename,v' this caused unneeded stress on certain functions
like cvs_file_classify() who had to do pointer voodoo to split out
the 'Attic/' part and do other very weird stuff to normalize the pathname
of these files.

Instead, we handle these files early in the start when we
build the fileslist in cvs_repository_getdir(). When encountering
the 'Attic/' directory, we recurse in it if required but instead of
using the 'Attic/' directory component as our base directory we stick
with the directory name where 'Attic/' resides in, resulting in the
correct filename while maintaining the correct RCSpath for the file.

This made the following things a lot easier:
(and in most cases actually fixed the below points)

- status with files in Attic/.
- checking out HEAD repositories with files in Attic/.
- checking out repositories with -rTAG.
- updating with -rTAG.

and as an added bonus the following now also works:

- correctly creating CVS/Tag in both local and remote mode thus
  allowing update/status/and more to work correctly with the tagged tree.
  (thanks to the correct handling of -rTAG cases).
- resetting tags with opencvs -A properly works too now.

This is a major step forward into the usability
of OpenCVS when it comes to maintaining multiple tagged trees, the next
logical step would be to fix commiting to branches.

enjoy you -stable cowards.

tested by myself, xsa, niallo and ckuethe
thanks guys!
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.96 2007/06/28 21:38:09 xsa Exp $	*/
d110 3
@


1.96
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.95 2007/06/27 03:58:16 joris Exp $	*/
a35 2
extern int reset_stickies;
extern char *tag;
d79 1
a79 1
			tag = xstrdup(optarg);
d138 3
a140 2
		if (tag != NULL)
			cvs_client_send_request("Argument -r%s", tag);
d177 2
a178 1
		cvs_mkpath(argv[i]);
d220 1
a220 1
	char template[MAXPATHLEN], *p, entry[CVS_ENT_MAXLINELEN];
d294 1
a294 1
		if (tag != NULL)
d296 1
a296 1
			    tag);
a323 3
		if ((p = strrchr(cf->file_rpath, ',')) != NULL)
			*p = '\0';

a358 3

		if (p != NULL)
			*p = ',';
@


1.95
log
@We were missing the needed clue/magic to have our remote setup
handle files that have been removed from the repository
correctly, which resulted in them still being in the working copy
after doing an update.

noticed and diff tested by ckuethe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.94 2007/06/18 17:54:13 joris Exp $	*/
d220 3
a222 2
	char template[MAXPATHLEN], *p, entry[CVS_ENT_MAXLINELEN], rev[16];
	char timebuf[64], kbuf[8], tbuf[32], stickytag[32];
@


1.94
log
@first stab at history stuff for opencvs, currently only writes
to CVSROOT/history but cannot parse it yet with the 'history' command.

"Commit it." ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.93 2007/06/01 17:47:47 niallo Exp $	*/
d317 5
a321 3
		ent = cvs_ent_open(cf->file_wd);
		cvs_ent_add(ent, entry);
		cvs_ent_close(ent, ENT_SYNC);
d335 2
d340 2
a341 1
		cvs_remote_output(entry);
d343 1
a343 1
		if (!(co_flags & CO_COMMIT)) {
@


1.93
log
@add support for local and remote branch checkout.  for example,
cvs co -rOPENBSD_3_0 works now.
along the way, simplify and rationalise code and fix a few nits.

ok joris@@ xsa@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.92 2007/02/22 06:42:09 otto Exp $	*/
d191 2
@


1.92
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.91 2007/02/18 10:30:45 otto Exp $	*/
d37 1
d80 3
d140 2
d291 6
a296 1
		(void)xsnprintf(stickytag, sizeof(stickytag), "T%s", rev);
@


1.91
log
@an erroneous free() crept in due to a merge error
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.90 2007/02/17 18:23:43 xsa Exp $	*/
d18 8
a25 1
#include "includes.h"
a27 1
#include "log.h"
@


1.90
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.89 2007/01/31 21:07:35 xsa Exp $	*/
a334 1
				xfree(template);
@


1.89
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.88 2007/01/28 23:39:42 joris Exp $	*/
d158 2
a159 3
		if (cvs_path_cat(current_cvsroot->cr_dir, argv[i], repo,
		    sizeof(repo)) >= sizeof(repo))
			fatal("checkout_check_repository: truncation");
@


1.88
log
@hey look, i found another debug printf from my merging stuff!
kill-zap-nuke-remove-delete it.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.87 2007/01/28 02:04:45 joris Exp $	*/
d202 1
a202 1
	int kflag, l, oflags, exists;
d273 1
a273 1
		l = snprintf(timebuf, sizeof(timebuf), "Result of merge+%s",
a274 2
		if (l == -1 || l >= (int)sizeof(timebuf))
			fatal("cvs_checkout_file: overflow");
d279 3
a281 5
	if (co_flags & CO_SETSTICKY) {
		l = snprintf(stickytag, sizeof(stickytag), "T%s", rev);
		if (l == -1 || l >= (int)sizeof(stickytag))
			fatal("cvs_checkout_file: overflow");
	} else {
a282 1
	}
d291 1
a291 1
			snprintf(kbuf, sizeof(kbuf),
d295 1
a295 1
	l = snprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s/%s/%s/%s",
d322 1
a322 1
				l = snprintf(template, MAXPATHLEN,
d324 1
a324 2
				if (l == -1 || l >= MAXPATHLEN)
					fatal("cvs_Checkout_file: overflow");
@


1.87
log
@add merging support in both local and remote sides.
tested by many, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.86 2007/01/26 21:59:11 otto Exp $	*/
a227 3

	if (co_flags & CO_MERGE)
		printf("merge on %s\n", cf->file_path);
@


1.86
log
@more fixe size buffers on the stack. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.85 2007/01/26 21:48:17 xsa Exp $	*/
d206 1
d210 2
d229 3
d233 17
a249 7
		oflags = O_WRONLY | O_TRUNC;
		if (cf->fd != -1) {
			exists = 1;
			(void)close(cf->fd);
		} else  {
			exists = 0;
			oflags |= O_CREAT;
a251 6
		cf->fd = open(cf->file_path, oflags);
		if (cf->fd == -1)
			fatal("cvs_checkout_file: open: %s", strerror(errno));

		rcs_rev_write_fd(cf->file_rcs, rnum, cf->fd, 1);

d255 2
a256 1
		if (exists == 0 && cf->file_ent == NULL)
d314 5
d321 2
d329 18
a346 9
			l = snprintf(template, MAXPATHLEN,
			    "%s/checkout.XXXXXXXXXX", cvs_tmpdir);
			if (l == -1 || l >= (int)sizeof(template))
				fatal("cvs_checkout_file: overflow");

			/* XXX - fd race below */
			rcs_rev_write_stmp(cf->file_rcs, rnum, template, 0);
			cvs_remote_send_file(template);
			cvs_worklist_run(&temp_files, cvs_worklist_unlink);
@


1.85
log
@- support [-k mode] for the add command
- do not let the file keyword expension options (-k) disappear
from the Entries file when doing a commit/update/checkout
- be sure the expension mode gets written to the RCS file when a file
is added/committed in the first place
problems raised by otto@@; tests/ok otto@@ and joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.84 2007/01/26 11:19:44 joris Exp $	*/
d206 2
a207 2
	char *template, *p, *entry, rev[16], timebuf[64];
	char kbuf[8], tbuf[32], stickytag[32];
a291 1
	entry = xmalloc(CVS_ENT_MAXLINELEN);
d311 1
a311 1
			(void)xasprintf(&template,
d313 2
a319 1
			xfree(template);
a324 2

	xfree(entry);
@


1.84
log
@Handle CVS/Entries and file timestamp correctly so we do
not mistakenly see a file as Modified while it is not.

As a result, we can remove the very hackish cvs_hack_time() and
GNU cvs and opencvs should almost get along now.

lotsa help and okay The otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.83 2007/01/25 23:22:32 joris Exp $	*/
d202 1
a202 1
	int l, oflags, exists;
d207 1
a207 1
	char tbuf[32], stickytag[32];
d281 11
d293 2
a294 2
	l = snprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s/%s//%s", cf->file_name,
	    rev, timebuf, stickytag);
@


1.83
log
@when acting as a server - immediatly after we checkout a file
remove its temp copy so our worklist doesnt contain a
bazillion entries when checking out src.

as a result, we now use very little memory in server mode.

found and tested by otto@@
ok cool and the gang.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.82 2007/01/18 08:49:08 xsa Exp $	*/
d245 1
a245 1
		if (exists == 0) {
d247 1
a247 2
			rcstime = cvs_hack_time(rcstime, 0);
		} else {
a248 1
		}
d260 1
a260 3
	rcstime = cvs_hack_time(rcstime, 1);

	ctime_r(&rcstime, tbuf);
@


1.82
log
@put functions protos at the right place.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.81 2007/01/17 22:39:50 thib Exp $	*/
d311 1
a311 1
			(void)unlink(template);
@


1.81
log
@on checkout, only create the module path if we find the module.
Also make error ouput match GNU CVS.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.80 2007/01/17 20:38:50 xsa Exp $	*/
a23 3

int	cvs_checkout(int, char **);
int	cvs_export(int, char **);
@


1.80
log
@send -l Argument to server when appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.79 2007/01/17 17:54:50 joris Exp $	*/
a160 2
		cvs_mkpath(argv[i]);

d166 1
a166 1
			cvs_log(LP_ERR, "cannot find repository %s - ignored",
d170 1
a170 1

@


1.79
log
@add support for remote checkout in both our client and server,
with this the last real dependency to actually be able to use opencvs
in a remote setup has been added.

based upon an initial diff from xsa@@
'kay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.78 2007/01/16 08:33:46 xsa Exp $	*/
d135 3
@


1.78
log
@better, share -l and -R flags between checkout and export cmds.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.77 2007/01/16 08:17:27 xsa Exp $	*/
d128 28
@


1.77
log
@handle -l and -R for checkout too.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.76 2007/01/14 22:20:46 xsa Exp $	*/
d35 2
d61 1
a61 3
	int ch, flags;

	flags = CR_RECURSE_DIRS;
d95 1
a95 1
	int ch, flags;
a97 1
	flags = CR_RECURSE_DIRS;
d159 1
a159 1
	cr.flags = CR_REPO | CR_RECURSE_DIRS;
d174 1
a174 1
cvs_checkout_file(struct cvs_file *cf, RCSNUM *rnum, int flags)
d186 1
a186 1
	    cf->file_path, rev, flags,
d189 1
a189 1
	if (flags & CO_DUMP) {
d242 1
a242 1
	if (flags & CO_MERGE) {
d251 1
a251 1
	if (flags & CO_SETSTICKY) {
d271 1
a271 1
		if (flags & CO_COMMIT)
d278 1
a278 1
		if (!(flags & CO_COMMIT)) {
@


1.76
log
@reset sticky tags with -A; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.75 2007/01/14 18:44:55 joris Exp $	*/
d41 1
a41 1
	"AcD:d:fj:k:lNnPRr:st:",
d59 3
a61 1
	int ch;
d68 3
d73 2
@


1.75
log
@replace checkout_write_revision() with rcs_rev_write_stmp()
they do exactly the same anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.74 2007/01/13 15:56:15 joris Exp $	*/
d33 1
d63 3
@


1.74
log
@plug 3 memleaks
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.73 2007/01/13 15:45:59 joris Exp $	*/
a29 1
static void checkout_write_revision(RCSFILE *, RCSNUM *, char *);
d273 1
a273 1
			checkout_write_revision(cf->file_rcs, rnum, template);
a283 13
}

static void
checkout_write_revision(RCSFILE *rfp, RCSNUM *rev, char *template)
{
	int fd;

	if ((fd = mkstemp(template)) == -1)
		fatal("mkstemp: '%s': %s", template, strerror(errno));

	cvs_worklist_add(template, &temp_files);
	rcs_rev_write_fd(rfp, rev, fd, 0);
	(void)close(fd);
@


1.73
log
@remove BUF * argument from cvs_checkout_file() it will
no longer be used, ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.72 2007/01/13 15:29:34 joris Exp $	*/
d277 1
@


1.72
log
@- remote update now works again, with new rcs api
- we no longer hold the entire file in memory when sending or receiving it
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.71 2007/01/12 23:56:11 joris Exp $	*/
d165 1
a165 1
cvs_checkout_file(struct cvs_file *cf, RCSNUM *rnum, BUF *bp, int flags)
@


1.71
log
@simplify after recent rcs API changes.
kay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.70 2007/01/12 23:32:01 niallo Exp $	*/
d27 1
d30 1
d171 2
a172 1
	char *p, *entry, rev[16], timebuf[64], tbuf[32], stickytag[32];
d270 2
a271 5
#if 0
			cvs_remote_output("u=rw,g=rw,o=rw");

			/* XXX */
			printf("%ld\n", cvs_buf_len(nbp));
d273 4
a276 4
			if (cvs_buf_write_fd(nbp, STDOUT_FILENO) == -1)
				fatal("cvs_checkout_file: failed to send file");
			cvs_buf_free(nbp);
#endif
d284 13
@


1.70
log
@major re-work of the RCS api.  this results in 100x performance improvements in some places and much
reduced memory usage.  note that only checkout has been fully converted to use the new high-performance
functions.  other codepaths (e.g. update) still use the old method which is provided for backwards
compatibility.  we can convert the remaining slow bits over to the new api piece-by-piece.

"commit this, now" joris@@
brad@@ tested, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.69 2007/01/03 22:28:30 joris Exp $	*/
a164 1
	BUF *nbp;
a170 2
	nbp = NULL;

a176 2
	if (bp != NULL)

d181 2
a182 7
			if (nbp == NULL) {
				rcs_rev_write_fd(cf->file_rcs, rnum,
				    STDOUT_FILENO, 1);
			} else {
				if (cvs_buf_write_fd(nbp, STDOUT_FILENO == -1))
					fatal("cvs_checkout_file: %s", strerror(errno));
			}
d202 1
a202 6
		if (nbp == NULL) {
			rcs_rev_write_fd(cf->file_rcs, rnum, cf->fd, 1);
		} else {
			if (cvs_buf_write_fd(nbp, STDOUT_FILENO == -1))
				fatal("cvs_checkout_file: %s", strerror(errno));
		}
d267 1
d276 1
@


1.69
log
@add support for 'remove' in a remote setup.
testing appriciated, as always.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.68 2007/01/03 20:48:26 joris Exp $	*/
d172 2
d180 1
a180 1
	nbp = rcs_kwexp_buf(bp, cf->file_rcs, rnum);
d186 7
a192 2
			if (cvs_buf_write_fd(nbp, STDOUT_FILENO) == -1)
				fatal("cvs_checkout_file: %s", strerror(errno));
a194 1
		cvs_buf_free(nbp);
d212 6
a217 4
		if (cvs_buf_write_fd(nbp, cf->fd) == -1)
			fatal("cvs_checkout_file: %s", strerror(errno));

		cvs_buf_free(nbp);
@


1.68
log
@if we are commiting a file, do not let the server resend it
with an 'Updated' response, seeing as the client will already have the
latest version. Instead, send the correct 'Checked-in' response.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.67 2006/12/22 11:51:50 xsa Exp $	*/
d266 4
a269 6
		if (flags & CO_COMMIT) {
			cvs_server_send_response("Checked-in %s/",
			    cf->file_wd);
		} else {
			cvs_server_send_response("Updated %s/", cf->file_wd);
		}
a270 1
		cvs_remote_output(cf->file_rpath);
@


1.67
log
@snprintf() -> cvs_path_cat();
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.66 2006/07/07 17:37:17 joris Exp $	*/
d266 7
a272 1
		cvs_server_send_response("Updated %s/", cf->file_wd);
a274 1
		cvs_remote_output("u=rw,g=rw,o=rw");
d276 5
a280 2
		/* XXX */
		printf("%ld\n", cvs_buf_len(nbp));
d282 4
a285 3
		if (cvs_buf_write_fd(nbp, STDOUT_FILENO) == -1)
			fatal("cvs_checkout_file: failed to send file");
		cvs_buf_free(nbp);
@


1.66
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.65 2006/07/01 20:30:46 reyk Exp $	*/
d114 1
a114 1
	int i, l;
d121 3
a123 4
		l = snprintf(repo, sizeof(repo), "%s/%s",
		    current_cvsroot->cr_dir, argv[i]);
		if (l == -1 || l >= (int)sizeof(repo))
			fatal("checkout_check_repository: overflow");
@


1.65
log
@implement the -p (dump) flag for cvs update

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.64 2006/06/19 05:05:17 joris Exp $	*/
d23 1
d171 1
a171 1
	char *entry, rev[16], timebuf[64], tbuf[32], stickytag[32];
d175 3
a177 2
	cvs_log(LP_TRACE, "cvs_checkout_file(%s, %s, %d)",
	    cf->file_path, rev, flags);
d182 7
a188 2
		if (cvs_buf_write_fd(nbp, STDOUT_FILENO) == -1)
			fatal("cvs_checkout_file: %s", strerror(errno));
d193 35
a227 24
	oflags = O_WRONLY | O_TRUNC;
	if (cf->fd != -1) {
		exists = 1;
		(void)close(cf->fd);
	} else  {
		exists = 0;
		oflags |= O_CREAT;
	}

	cf->fd = open(cf->file_path, oflags);
	if (cf->fd == -1)
		fatal("cvs_checkout_file: open: %s", strerror(errno));

	if (cvs_buf_write_fd(nbp, cf->fd) == -1)
		fatal("cvs_checkout_file: %s", strerror(errno));

	cvs_buf_free(nbp);

	if (fchmod(cf->fd, 0644) == -1)
		fatal("cvs_checkout_file: fchmod: %s", strerror(errno));

	if (exists == 0) {
		rcstime = rcs_rev_getdate(cf->file_rcs, rnum);
		rcstime = cvs_hack_time(rcstime, 0);
a231 6
	tv[0].tv_sec = rcstime;
	tv[0].tv_usec = 0;
	tv[1] = tv[0];
	if (futimes(cf->fd, tv) == -1)
		fatal("cvs_checkout_file: futimes: %s", strerror(errno));

d259 23
a281 3
	ent = cvs_ent_open(cf->file_wd);
	cvs_ent_add(ent, entry);
	cvs_ent_close(ent, ENT_SYNC);
@


1.64
log
@kill local and remote callback and just have one called fileproc.
we let the commands pass the correct function.

all in preparation for remote.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.63 2006/06/16 14:07:42 joris Exp $	*/
d178 7
@


1.63
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.62 2006/06/14 20:28:53 joris Exp $	*/
d147 1
a147 2
	cr.local = cvs_update_local;
	cr.remote = NULL;
@


1.62
log
@simplify cvs_hack_time() and the way it is called;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.61 2006/06/06 06:58:46 xsa Exp $	*/
a22 1
#include "proto.h"
d33 1
a33 1
	CVS_OP_CHECKOUT, CVS_REQ_CO, "checkout",
d44 1
a44 1
	CVS_OP_EXPORT, CVS_REQ_EXPORT, "export",
@


1.61
log
@more bits for the export command to work correctly. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.60 2006/06/03 19:07:13 joris Exp $	*/
d204 1
a204 2
		if ((rcstime = cvs_hack_time(rcstime, 0)) == 0)
			fatal("cvs_checkout_file: time conversion failed");
d215 1
a215 2
	if ((rcstime = cvs_hack_time(rcstime, 1)) == 0)
		fatal("cvs_checkout_file: to gmt failed");
@


1.60
log
@add support for update -A and update -r<rev>.
hacking on the plane from toronto to barbados.

i will probably hack some more since im stuck in barbados
for 12 lovely hours over night cause the carribean airlines dont understand
the meaning over 'more than one flight a day'.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.59 2006/05/31 22:25:59 joris Exp $	*/
d26 2
d48 2
a49 2
	"module ...",
	"",
d51 1
a51 1
	cvs_checkout
d57 1
a57 3
	int i, ch, l;
	struct stat st;
	char repo[MAXPATHLEN];
d75 43
d124 1
a124 1
			fatal("cvs_checkout: overflow");
a133 2

	return (0);
@


1.59
log
@add support for the export command.

export does exactly the same as checkout except it does
not create any administrative (CVS/) directories.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.58 2006/05/28 01:24:28 joris Exp $	*/
d131 1
a131 1
	char *entry, rev[16], timebuf[64], tbuf[32];
d191 8
d200 2
a201 2
	l = snprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s/%s//", cf->file_name,
	    rev, timebuf);
@


1.58
log
@enable merging on update. if your file in your working copy
has been modified by yourself and there is a newer revision
we try and merge them together.

if the merge fails and has conflicts it will mark them inside
the file, you will need to resolve these by hand first before
you will be able to commit your modified file.

works transparent with gnu cvs, as it is suppose to.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.57 2006/05/27 16:10:01 joris Exp $	*/
d38 10
@


1.57
log
@support the -d flag for update.

if you specify -d when running update new directories will be build,
otherwise they will be skipped.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.56 2006/05/27 15:14:27 joris Exp $	*/
d113 2
a114 2
int
cvs_checkout_file(struct cvs_file *cf, RCSNUM *rnum, int flags)
d116 1
a116 1
	BUF *bp;
d121 1
a121 1
	char *entry, rev[16], timebuf[32];
d128 1
a128 7
	if ((bp = rcs_getrev(cf->file_rcs, rnum)) == NULL) {
		cvs_log(LP_ERR, "%s: cannot find revision %s",
		    cf->file_path, rev);
		return (0);
	}

	bp = rcs_kwexp_buf(bp, cf->file_rcs, rnum);
d143 1
a143 1
	if (cvs_buf_write_fd(bp, cf->fd) == -1)
d146 1
a146 1
	cvs_buf_free(bp);
d168 12
a179 3
	ctime_r(&rcstime, timebuf);
	if (timebuf[strlen(timebuf) - 1] == '\n')
		timebuf[strlen(timebuf) - 1] = '\0';
a189 2

	return (1);
@


1.56
log
@allow commands to respect the -l flag, if the -l flag is
specified certain commands will not recurse into directories.

at the same time introduce a method of specifying wether or not
a command should look in the repository for files.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.55 2006/05/27 05:59:32 joris Exp $	*/
d29 1
d94 1
@


1.55
log
@correctly expand keywords when checking out files
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.54 2006/05/27 05:20:25 joris Exp $	*/
d97 1
d100 1
a100 1
	cvs_repository_getdir(repobase, wdbase, &fl, &dl);
@


1.54
log
@pruning (-P) support for both the update and checkout commands;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.53 2006/05/27 03:30:30 joris Exp $	*/
d130 2
@


1.53
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 2
d50 3
d94 1
a94 1
	cr.leavedir = NULL;
@


1.52
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.51 2006/03/24 13:34:27 ray Exp $	*/
d3 1
a3 2
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d22 1
d25 2
a26 7

#define CVS_LISTMOD	1
#define CVS_STATMOD	2

static int	cvs_checkout_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_checkout_pre_exec(struct cvsroot *);
static int	cvs_checkout_local(CVSFILE *cf, void *);
d31 1
a31 1
	"Checkout sources for editing",
d36 1
a36 25
	0,
	cvs_checkout_init,
	cvs_checkout_pre_exec,
	NULL,
	NULL,
	NULL,
	NULL,
	CVS_CMD_ALLOWSPEC | CVS_CMD_SENDDIR
};

struct cvs_cmd cvs_cmd_export = {
	CVS_OP_EXPORT, CVS_REQ_EXPORT, "export",
	{ "ex", "exp" },
	"Extract copy of a module without management directories",
	"[-flNnR] [-d dir] [-k mode] -D date | -r tag module ...",
	"D:d:fk:lNnRr:",
	NULL,
	0,
	cvs_checkout_init,
	cvs_checkout_pre_exec,
	NULL,
	NULL,
	NULL,
	NULL,
	CVS_CMD_ALLOWSPEC | CVS_CMD_SENDDIR
d39 2
a40 17
static char *currepo = NULL;
static DIR *dirp = NULL;
static int cwdfd = -1;
static char *date, *tag, *koptstr, *tgtdir, *rcsid;
static int statmod = 0;
static int shorten = 0;
static int usehead = 0;
static int kflag = RCS_KWEXP_DEFAULT;

/* modules */
static char **co_mods;
static int    co_nmod;

/* XXX checkout has issues in remote mode, -N gets seen as module */

static int
cvs_checkout_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d42 3
a44 3
	int ch;

	date = tag = koptstr = tgtdir = rcsid = NULL;
d46 1
a46 1
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
a47 47
		case 'A':
			break;
		case 'c':
			statmod = CVS_LISTMOD;
			break;
		case 'D':
			date = optarg;
			cmd->cmd_flags |= CVS_CMD_PRUNEDIRS;
			break;
		case 'd':
			tgtdir = optarg;
			shorten = 1;
			break;
		case 'f':
			usehead = 1;
			break;
		case 'j':
			break;
		case 'k':
			koptstr = optarg;
			kflag = rcs_kflag_get(koptstr);
			if (RCS_KWEXP_INVAL(kflag)) {
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
				rcs_kflag_usage();
				return (CVS_EX_USAGE);
			}
			break;
		case 'P':
			cmd->cmd_flags |= CVS_CMD_PRUNEDIRS;
			break;
		case 'N':
			shorten = 0;
			break;
		case 'p':
			cvs_noexec = 1;	/* no locks will be created */
			break;
		case 'r':
			tag = optarg;
			cmd->cmd_flags |= CVS_CMD_PRUNEDIRS;
			break;
		case 's':
			statmod = CVS_STATMOD;
			break;
		case 't':
			rcsid = optarg;
			break;
d49 1
a49 1
			return (CVS_EX_USAGE);
d56 2
a57 2
	co_mods = argv;
	co_nmod = argc;
d59 2
a60 2
	if (statmod == 0 && argc == 0)
		fatal("must specify at least one module or directory");
d62 4
a65 2
	if (statmod && (argc > 0))
		fatal("-c and -s must not get any arguments");
d67 7
a73 8
	/* `export' command exceptions */
	if (cvs_cmdop == CVS_OP_EXPORT) {
		if (tag == NULL && date == NULL)
			fatal("must specify a tag or date");

		/* we don't want numerical revisions here */
		if (tag != NULL && rcsnum_parse(tag) != NULL)
			fatal("tag `%s' must be a symbolic tag", tag);
a75 1
	*arg = optind;
d79 2
a80 2
static int
cvs_checkout_pre_exec(struct cvsroot *root)
d82 5
a86 2
	int i, ret;
	char *sp, repo[MAXPATHLEN];
d88 4
a91 2
	if ((dirp = opendir(".")) == NULL)
		fatal("cvs_checkout_pre_exec: opendir failed");
d93 2
a94 1
	cwdfd = dirfd(dirp);
d96 2
a97 3
	for (i = 0; i < co_nmod; i++) {
		if ((sp = strchr(co_mods[i], '/')) != NULL)
			*sp = '\0';
d99 1
a99 3
		if (mkdir(co_mods[i], 0755) == -1 && errno != EEXIST)
			fatal("cvs_checkout_pre_exec: mkdir `%s': %s",
			    co_mods[i], strerror(errno));
d101 3
a103 2
		cvs_mkadmin(co_mods[i], root->cr_str, co_mods[i], NULL,
		    NULL, 0);
d105 9
a113 3
		if (sp != NULL)
			*sp = '/';
	}
d115 1
a115 22
	if (root->cr_method == CVS_METHOD_LOCAL) {
		if ((dirp = opendir(".")) == NULL)
			fatal("cvs_checkout_pre_exec: opendir failed");

		cwdfd = dirfd(dirp);

		for (i = 0; i < co_nmod; i++) {
			if (strlcpy(repo, root->cr_dir, sizeof(repo)) >=
			    sizeof(repo) ||
			    strlcat(repo, "/", sizeof(repo)) >= sizeof(repo) ||
			    strlcat(repo, co_mods[i], sizeof(repo)) >=
			    sizeof(repo))
				fatal("cvs_checkout_pre_exec: path truncation");

			currepo = co_mods[i];
			ret = cvs_file_get(repo, CF_RECURSE | CF_REPO |
			    CF_IGNORE, cvs_checkout_local, NULL, NULL);
			if (ret != CVS_EX_OK) {
				closedir(dirp);
				return (ret);
			}
		}
d117 2
a118 21
		closedir(dirp);
	} else {
		/*
		 * These arguments are for the expand-modules
		 * command that we send to the server before requesting
		 * a checkout.
		 */
		for (i = 0; i < co_nmod; i++)
			cvs_sendarg(root, co_mods[i], 0);

		cvs_sendreq(root, CVS_REQ_DIRECTORY, ".");
		cvs_sendln(root, root->cr_dir);
		cvs_sendreq(root, CVS_REQ_XPANDMOD, NULL);

		if (usehead == 1)
			cvs_sendarg(root, "-f", 0);

		if (tgtdir != NULL) {
			cvs_sendarg(root, "-d", 0);
			cvs_sendarg(root, tgtdir, 0);
		}
d120 5
a124 2
		if (shorten == 0)
			cvs_sendarg(root, "-N", 0);
d126 8
a133 2
		if (cvs_cmd_checkout.cmd_flags & CVS_CMD_PRUNEDIRS);
			cvs_sendarg(root, "-P", 0);
d135 3
a137 2
		for (i = 0; i < co_nmod; i++)
			cvs_sendarg(root, co_mods[i], 0);
d139 2
a140 9
		if (statmod == CVS_LISTMOD)
			cvs_sendarg(root, "-c", 0);
		else if (statmod == CVS_STATMOD)
			cvs_sendarg(root, "-s", 0);

		if (tag != NULL) {
			cvs_sendarg(root, "-r", 0);
			cvs_sendarg(root, tag, 0);
		}
d142 1
a142 5
		if (date != NULL) {
			cvs_sendarg(root, "-D", 0);
			cvs_sendarg(root, date, 0);
		}
	}
d144 2
a145 2
	return (0);
}
d147 6
a152 12
static int
cvs_checkout_local(CVSFILE *cf, void *arg)
{
	char rcspath[MAXPATHLEN], fpath[MAXPATHLEN];
	RCSFILE *rf;
	struct cvsroot *root;
	static int inattic = 0;

	/* we don't want these */
	if (cf->cf_type == DT_DIR && !strcmp(cf->cf_name, "Attic")) {
		inattic = 1;
		return (CVS_EX_OK);
d155 5
a159 1
	root = CVS_DIR_ROOT(cf);
d161 2
a162 2
	cvs_file_getpath(cf, fpath, sizeof(fpath));
	cvs_rcs_getpath(cf, rcspath, sizeof(rcspath));
d164 3
a166 24
	if (cf->cf_type == DT_DIR) {
		inattic = 0;
		if (verbosity > 1)
			cvs_log(LP_INFO, "Updating %s", fpath);

		if (cvs_cmdop != CVS_OP_SERVER) {
			/*
			 * We pass an empty repository name to
			 * cvs_create_dir(), because it will correctly
			 * create the repository directory for us.
			 */
			if (cvs_create_dir(fpath, 1, root->cr_dir, NULL) < 0)
				fatal("cvs_checkout_local: cvs_create_dir failed");
			if (fchdir(cwdfd) < 0)
				fatal("cvs_checkout_local: fchdir failed");
		} else {
			/*
			 * TODO: send responses to client so it'll
			 * create it's directories.
			 */
		}

		return (CVS_EX_OK);
	}
d168 3
a170 2
	if (inattic == 1)
		return (CVS_EX_OK);
d172 3
a174 3
	if ((rf = rcs_open(rcspath, RCS_READ)) == NULL)
		fatal("cvs_checkout_local: rcs_open `%s': %s", rcspath,
		    rcs_errstr(rcs_errno));
d176 1
a176 4
	if (cvs_checkout_rev(rf, rf->rf_head, cf, fpath,
	    (cvs_cmdop != CVS_OP_SERVER) ? 1 : 0,
	    CHECKOUT_REV_CREATED) < 0)
		fatal("cvs_checkout_local: cvs_checkout_rev failed");
d178 1
a178 4
	rcs_close(rf);

	cvs_printf("U %s\n", fpath);
	return (0);
@


1.51
log
@Remove unused variables, better integer types, prevent fallthroughs.
Found by lint.

Compare char * variables against NULL for consistency and add
parentheses around complicated comparisons, suggested by xsa@@.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.50 2006/01/31 13:55:20 xsa Exp $	*/
d158 1
a158 1
	if ((statmod == 0) && (argc == 0))
d166 1
a166 1
		if ((tag == NULL) && (date == NULL))
d170 1
a170 1
		if ((tag != NULL) && (rcsnum_parse(tag) != NULL))
d193 1
a193 1
		if ((mkdir(co_mods[i], 0755) == -1) && (errno != EEXIST))
d286 1
a286 1
	if ((cf->cf_type == DT_DIR) && !strcmp(cf->cf_name, "Attic")) {
@


1.50
log
@errors in cvs_checkout_init() are definitly fatal.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.49 2006/01/30 17:58:47 xsa Exp $	*/
a94 1
	RCSNUM *rcs;
d166 1
a166 1
		if (!tag && !date)
d170 1
a170 1
		if (tag && (rcs = rcsnum_parse(tag)) != NULL)
@


1.49
log
@strerror() -> rcs_errstr() when passing rcs_errno as argument;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.48 2006/01/27 12:56:28 xsa Exp $	*/
d159 2
a160 5
	if ((statmod == 0) && (argc == 0)) {
		cvs_log(LP_ABORT,
		    "must specify at least one module or directory");
		return (-1);
	}
d162 2
a163 4
	if (statmod && (argc > 0)) {
		cvs_log(LP_ABORT,  "-c and -s must not get any arguments");
		return (-1);
	}
d167 2
a168 4
		if (!tag && !date) {
			cvs_log(LP_ABORT, "must specify a tag or date");
			return (-1);
		}
d171 2
a172 6
		if (tag && (rcs = rcsnum_parse(tag)) != NULL) {
			cvs_log(LP_ABORT, "tag `%s' must be a symbolic tag",
			    tag);
			rcsnum_free(rcs);
			return (-1);
		}
@


1.48
log
@cvs_mkadmin() cannot return < 0 anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.47 2006/01/27 12:45:21 xsa Exp $	*/
d338 1
a338 1
		    strerror(rcs_errno));
@


1.47
log
@errors handling cleaning here too;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.46 2006/01/27 10:53:23 xsa Exp $	*/
d209 2
a210 4
		if (cvs_mkadmin(co_mods[i], root->cr_str, co_mods[i],
		    NULL, NULL, 0) < 0)
			fatal("cvs_checkout_pre_exec: cvs_mkadmin `%s' failed",
			    co_mods[i]);
@


1.46
log
@errors handling cleaning here too;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.45 2006/01/25 12:16:13 xsa Exp $	*/
d322 3
a324 5
				return (CVS_EX_FILE);
			if (fchdir(cwdfd) < 0) {
				cvs_log(LP_ERRNO, "fchdir failed");
				return (CVS_EX_FILE);
			}
@


1.45
log
@use cvs_rcs_getpath() here too + some strings cleanup whilst here.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.44 2006/01/02 08:11:56 xsa Exp $	*/
d196 2
a197 4
	if ((dirp = opendir(".")) == NULL) {
		cvs_log(LP_ERRNO, "failed to save cwd");
		return (CVS_EX_DATA);
	}
d205 3
a207 5
		if ((mkdir(co_mods[i], 0755) == -1) && (errno != EEXIST)) {
			cvs_log(LP_ERRNO, "can't create base directory '%s'",
			    co_mods[i]);
			return (CVS_EX_DATA);
		}
d210 2
a211 2
		    NULL, NULL, 0) < 0) {
			cvs_log(LP_ERR, "can't create base directory '%s'",
a212 2
			return (CVS_EX_DATA);
		}
d220 2
a221 1
			return (CVS_EX_DATA);
d340 3
a342 4
	if ((rf = rcs_open(rcspath, RCS_READ)) == NULL) {
		cvs_log(LP_ERR, "cvs_checkout_local: rcs_open failed");
		return (CVS_EX_DATA);
	}
d346 2
a347 4
	    CHECKOUT_REV_CREATED) < 0) {
		rcs_close(rf);
		return (CVS_EX_DATA);
	}
d352 1
a352 1
	return (CVS_EX_OK);
@


1.44
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.43 2005/12/30 17:51:01 reyk Exp $	*/
d230 7
a236 2
			snprintf(repo, sizeof(repo), "%s/%s", root->cr_dir,
			    co_mods[i]);
d311 1
d313 1
a313 3

	snprintf(rcspath, sizeof(rcspath), "%s/%s%s", root->cr_dir,
	    fpath, RCS_FILE_EXT);
@


1.43
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.42 2005/12/30 02:03:28 joris Exp $	*/
d27 1
a27 8
#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.42
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.41 2005/12/03 01:02:08 joris Exp $	*/
d240 2
a241 2
			ret = cvs_file_get(repo, CF_RECURSE | CF_REPO | CF_IGNORE,
			    cvs_checkout_local, NULL, NULL);
@


1.41
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.40 2005/09/15 17:01:10 xsa Exp $	*/
d256 19
a274 24
			if (cvs_sendarg(root, co_mods[i], 0) < 0)
				return (CVS_EX_PROTO);
		if (cvs_sendreq(root, CVS_REQ_DIRECTORY, ".") < 0)
			return (CVS_EX_PROTO);
		if (cvs_sendln(root, root->cr_dir) < 0)
			return (CVS_EX_PROTO);

		if (cvs_sendreq(root, CVS_REQ_XPANDMOD, NULL) < 0)
			cvs_log(LP_ERR, "failed to expand module");

		if ((usehead == 1) && (cvs_sendarg(root, "-f", 0) < 0))
			return (CVS_EX_PROTO);

		if ((tgtdir != NULL) &&
		    ((cvs_sendarg(root, "-d", 0) < 0) ||
		    (cvs_sendarg(root, tgtdir, 0) < 0)))
			return (CVS_EX_PROTO);

		if ((shorten == 0) && cvs_sendarg(root, "-N", 0) < 0)
			return (CVS_EX_PROTO);

		if ((cvs_cmd_checkout.cmd_flags & CVS_CMD_PRUNEDIRS) &&
		    (cvs_sendarg(root, "-P", 0) < 0))
			return (CVS_EX_PROTO);
d277 1
a277 2
			if (cvs_sendarg(root, co_mods[i], 0) < 0)
				return (CVS_EX_PROTO);
d279 14
a292 14
		if ((statmod == CVS_LISTMOD) &&
		    (cvs_sendarg(root, "-c", 0) < 0))
			return (CVS_EX_PROTO);
		else if ((statmod == CVS_STATMOD) &&
		    (cvs_sendarg(root, "-s", 0) < 0))
			return (CVS_EX_PROTO);

		if ((tag != NULL) && ((cvs_sendarg(root, "-r", 0) < 0) ||
		    (cvs_sendarg(root, tag, 0) < 0)))
			return (CVS_EX_PROTO);

		if ((date != NULL) && ((cvs_sendarg(root, "-D", 0) < 0) ||
		    (cvs_sendarg(root, date, 0) < 0)))
			return (CVS_EX_PROTO);
d294 1
@


1.40
log
@check in cvs_mkadmin() wether we need to create or not the
CVS/Tag file. Sync the rest of the code accordingly; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.39 2005/07/25 12:05:43 xsa Exp $	*/
d46 1
d83 3
d96 2
d200 9
a208 2
	int i;
	char *sp;
d231 19
a249 1
	if (root->cr_method != CVS_METHOD_LOCAL) {
d301 68
@


1.39
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.38 2005/07/24 17:48:05 xsa Exp $	*/
d207 2
a208 1
		if (cvs_mkadmin(co_mods[i], root->cr_str, co_mods[i]) < 0) {
@


1.38
log
@some more `if (!var)' cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.37 2005/07/08 08:54:43 joris Exp $	*/
d41 2
a42 2
#define CVS_LISTMOD    1
#define CVS_STATMOD    2
d44 2
a45 2
static int cvs_checkout_init     (struct cvs_cmd *, int, char **, int *);
static int cvs_checkout_pre_exec (struct cvsroot *);
@


1.37
log
@

- revert previous commit a bit, those arguments belonged to expand-modules.
- send -N by default, to match GNU's behaviour.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.36 2005/07/08 08:24:09 joris Exp $	*/
d160 1
a160 1
	if (!statmod && (argc == 0)) {
d234 1
a234 1
		if (usehead && (cvs_sendarg(root, "-f", 0) < 0))
d242 1
a242 1
		if (!shorten && cvs_sendarg(root, "-N", 0) < 0)
@


1.36
log
@

do not send the Arguments to the server twice.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.35 2005/07/07 14:27:57 joris Exp $	*/
d84 1
a84 1
static int shorten = 1;
d113 1
d218 8
@


1.35
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.34 2005/06/28 08:54:54 xsa Exp $	*/
a216 3
		for (i = 0; i < co_nmod; i++)
			if (cvs_sendarg(root, co_mods[i], 0) < 0)
				return (CVS_EX_PROTO);
@


1.34
log
@send date;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.33 2005/06/13 07:40:39 xsa Exp $	*/
d194 1
a194 1
	char *sp; 
@


1.33
log
@`export' command first bits .. ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.32 2005/06/09 09:01:50 xsa Exp $	*/
d256 4
@


1.32
log
@-D implies pruning directories, as already does -r; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.31 2005/06/09 07:24:39 xsa Exp $	*/
d51 1
a51 1
	"[-AcflNnPpRs] [-D date | -r rev] [-d dir] [-j rev] [-k mode] "
d65 18
a82 1
static char *date, *rev, *koptstr, *tgtdir, *rcsid;
d96 1
d98 1
a98 1
	date = rev = koptstr = tgtdir = rcsid = NULL;
d139 1
a139 1
			rev = optarg;
d170 16
d252 4
@


1.31
log
@LP_ERR -> LP_ABORT to match gnu/usr.bin/cvs output; okay joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.30 2005/06/07 15:34:24 xsa Exp $	*/
d91 1
@


1.30
log
@silly me. do not abuse the copy/paste skills i have ...
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.29 2005/06/07 15:13:25 xsa Exp $	*/
d141 1
a141 1
		cvs_log(LP_ERR,
d147 1
a147 1
		cvs_log(LP_ERR,  "-c and -s must not get any arguments");
@


1.29
log
@enable -P option .. joris@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.28 2005/05/31 08:58:47 xsa Exp $	*/
d204 1
a204 1
		if ((cvs_cmd_update.cmd_flags & CVS_CMD_PRUNEDIRS) &&
@


1.28
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.27 2005/05/31 08:26:40 xsa Exp $	*/
d202 4
@


1.27
log
@remove LP_ERROR log priority level and rather use LP_ERR as they are both
the same...

ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.26 2005/05/30 07:39:21 xsa Exp $	*/
d33 1
a34 1
#include <string.h>
a37 1
#include "file.h"
@


1.26
log
@dont return CVS_EX_USAGE when not needed; ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.25 2005/05/29 17:48:44 xsa Exp $	*/
d173 1
a173 1
			cvs_log(LP_ERROR, "can't create base directory '%s'",
@


1.25
log
@-r implies -P (Prune empty directories);
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.24 2005/05/26 03:07:20 joris Exp $	*/
d144 1
a144 1
		return (CVS_EX_USAGE);
d149 1
a149 1
		return (CVS_EX_USAGE);
@


1.24
log
@

first part of real pruning support

okay jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.23 2005/05/24 20:04:43 joris Exp $	*/
d122 1
@


1.23
log
@

- simplify cvs_mkadmin().
- create the correct base paths in checkout.
- remove the CVS_CMD_SENDARGS2 flag for checkout, it doesn't need it.

okay jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.22 2005/05/24 04:12:25 jfb Exp $	*/
d110 3
@


1.22
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.21 2005/05/23 17:30:35 xsa Exp $	*/
d28 1
d63 1
a63 1
	CVS_CMD_ALLOWSPEC | CVS_CMD_SENDDIR | CVS_CMD_SENDARGS2
d156 1
a157 1
	/* create any required base directories */
d159 12
a170 1
		if (cvs_file_create(NULL, co_mods[i], DT_DIR, 0755) < 0)
d172 4
@


1.21
log
@add -f flag; ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.20 2005/05/20 18:26:49 xsa Exp $	*/
d44 2
a45 2
int cvs_checkout_options(char *, int, char **, int *);
int cvs_checkout_sendflags(struct cvsroot *);
d47 8
a54 4
struct cvs_cmd_info cvs_checkout = {
	cvs_checkout_options,
	cvs_checkout_sendflags,
	NULL, NULL, NULL,
d56 7
a62 2
	CVS_REQ_CO,
	CVS_CMD_SENDDIR | CVS_CMD_SENDARGS1 | CVS_CMD_SENDARGS2
d67 2
a69 1
static int usehead;
d71 6
a76 2
int
cvs_checkout_options(char *opt, int argc, char **argv, int *arg)
a80 2
	kflag = RCS_KWEXP_DEFAULT;
	usehead = 0;
d82 1
a82 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d110 3
d133 3
d151 2
a152 2
int
cvs_checkout_sendflags(struct cvsroot *root)
d154 1
a154 24
	if (cvs_sendreq(root, CVS_REQ_DIRECTORY, ".") < 0)
		return (CVS_EX_PROTO);
	if (cvs_sendraw(root, root->cr_dir, strlen(root->cr_dir)) < 0)
		return (CVS_EX_PROTO);
	if (cvs_sendraw(root, "\n", 1) < 0)
		return (CVS_EX_PROTO);

	if (cvs_sendreq(root, CVS_REQ_XPANDMOD, NULL) < 0)
		cvs_log(LP_ERR, "failed to expand module");

	if (usehead && (cvs_sendarg(root, "-f", 0) < 0))
		 return (CVS_EX_PROTO);

	/* XXX not too sure why we have to send this arg */
	if (cvs_sendarg(root, "-N", 0) < 0)
		return (CVS_EX_PROTO);

	if ((statmod == CVS_LISTMOD) &&
	    (cvs_sendarg(root, "-c", 0) < 0))
		return (CVS_EX_PROTO);

	if ((statmod == CVS_STATMOD) &&
	    (cvs_sendarg(root, "-s", 0) < 0))
		return (CVS_EX_PROTO);
d156 40
@


1.20
log
@first bits of the `cvs -n' option; ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.19 2005/05/20 05:13:44 joris Exp $	*/
d59 1
d68 1
d84 1
d145 3
@


1.19
log
@

execute the command callback at the same time we are building
the in-memory filelist. cuts down on execution time for larger trees.

"put it in!" jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.18 2005/04/12 14:58:40 joris Exp $	*/
d94 3
@


1.18
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.17 2005/04/11 18:02:58 joris Exp $	*/
d130 1
a130 1
	if (cvs_senddir(root, cvs_files) < 0)
d132 5
@


1.17
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.16 2005/04/11 17:56:27 joris Exp $	*/
d92 1
a92 1
				return (1);
d105 1
a105 1
			return (1);
d115 1
a115 1
		return (1);
d120 1
a120 1
		return (1);
d131 1
a131 1
		return (-1);
d137 1
a137 1
		return (-1);
d141 1
a141 1
		return (-1);
d145 1
a145 1
		return (-1);
@


1.16
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.15 2005/04/03 17:32:50 xsa Exp $	*/
a33 1
#include <sysexits.h>
@


1.15
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.14 2005/03/30 17:43:04 joris Exp $	*/
d93 1
a93 1
				return (EX_USAGE);
d106 1
a106 1
			return (EX_USAGE);
d116 1
a116 1
		return (EX_USAGE);
d121 1
a121 1
		return (EX_USAGE);
@


1.14
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.13 2005/02/22 22:12:00 jfb Exp $	*/
d132 1
a132 1
		return (EX_PROTOCOL);
d138 1
a138 1
		return (EX_PROTOCOL);
d142 1
a142 1
		return (EX_PROTOCOL);
d146 1
a146 1
		return (EX_PROTOCOL);
@


1.13
log
@- support -c and -s to retrieve the module list
- silently accept most of the other options supported by checkout
- do not abandon all hope if the `expand-modules' request fails
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.12 2004/12/14 01:11:51 jfb Exp $	*/
d45 15
a60 6
/*
 * cvs_checkout()
 *
 * Handler for the `cvs checkout' command.
 * Returns 0 on success, or one of the known system exit codes on failure.
 */
d62 1
a62 1
cvs_checkout(int argc, char **argv)
d64 3
a66 7
	int i, ch, statmod, kflag;
	char *date, *rev, *koptstr, *tgtdir, *rcsid;
	struct cvsroot *root;

	statmod = 0;
	rcsid = NULL;
	tgtdir = NULL;
d69 1
a69 1
	while ((ch = getopt(argc, argv, "AcD:d:fj:k:lNnPRr:st:")) != -1) {
d124 3
a126 2
	if ((cvs_files = cvs_file_get(".", 0)) == NULL)
		return (EX_USAGE);
d128 19
a146 44
	root = CVS_DIR_ROOT(cvs_files);
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_connect(root) < 0)
			return (EX_DATAERR);

		/* first send the expand modules command */
		for (i = 0; i < argc; i++)
			if (cvs_sendarg(root, argv[i], 0) < 0)
				break;

		if (cvs_senddir(root, cvs_files) < 0)
			return (EX_PROTOCOL);
		if (cvs_sendreq(root, CVS_REQ_XPANDMOD, NULL) < 0)
			cvs_log(LP_ERR, "failed to expand module");

		/* XXX not too sure why we have to send this arg */
		if (cvs_sendarg(root, "-N", 0) < 0)
			return (EX_PROTOCOL);

		if ((statmod == CVS_LISTMOD) &&
		    (cvs_sendarg(root, "-c", 0) < 0))
			return (EX_PROTOCOL);

		if ((statmod == CVS_STATMOD) &&
		    (cvs_sendarg(root, "-s", 0) < 0))
			return (EX_PROTOCOL);

		for (i = 0; i < argc; i++)
			if (cvs_sendarg(root, argv[i], 0) < 0)
				return (EX_PROTOCOL);

		if ((cvs_senddir(root, cvs_files) < 0) ||
		    (cvs_sendreq(root, CVS_REQ_CO, NULL) < 0)) {
			cvs_log(LP_ERR, "failed to checkout");
			return (EX_PROTOCOL);
		}
	}
@


1.12
log
@cleaner error handling on connection setup and in case of connection
failure
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.11 2004/12/07 17:10:56 tedu Exp $	*/
d42 3
d55 2
a56 1
	int i, ch;
d59 6
a64 1
	while ((ch = getopt(argc, argv, "c")) != -1) {
d66 2
d69 30
d108 1
a108 1
	if (argc == 0) {
d114 5
d139 3
a141 2
		if ((cvs_senddir(root, cvs_files) < 0) ||
		    (cvs_sendreq(root, CVS_REQ_XPANDMOD, NULL) < 0))
d146 8
@


1.11
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: checkout.c,v 1.10 2004/11/26 16:05:13 jfb Exp $	*/
d73 1
a73 2
	cvs_files = cvs_file_get(".", 0);
	if (cvs_files == NULL) {
a74 1
	}
d85 2
a86 1
		cvs_connect(root);
d99 1
a99 1
			exit(1);
d103 1
a103 1
				exit(EX_OSERR);
d108 1
@


1.10
log
@Match more closely the data sent by GNU CVS when dealing with multiple
modules.  Our checkout command can now perform the checkout of several
modules at once.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a48 1

@


1.9
log
@Add error checking and move the protocol calls so we only send them if
the cvs server is remote
@
text
@d53 1
a53 1
	int ch;
d56 1
a56 1
	while ((ch = getopt(argc, argv, "")) != -1) {
d58 2
d75 3
a77 2
	if (cvs_files == NULL)
		return (EX_DATAERR);
d80 7
d90 6
a95 2
		if ((cvs_sendarg(root, argv[0], 0) < 0) ||
		    (cvs_senddir(root, cvs_files) < 0) ||
d100 9
a108 4
		if ((cvs_sendarg(root, "-N", 0) < 0) ||
		    (cvs_sendarg(root, argv[0], 0) < 0) ||
		    (cvs_senddir(root, cvs_files) < 0) ||
		    (cvs_sendreq(root, CVS_REQ_CO, NULL) < 0))
d110 1
@


1.8
log
@Start using the global files list
@
text
@d72 4
a75 1
	cvs_files = cvs_file_get(".", CF_IGNORE);
a78 1
	}
d80 4
a83 3
	cvs_sendarg(root, argv[0], 0);
	cvs_senddir(root, cvs_files);
	cvs_sendreq(root, CVS_REQ_XPANDMOD, NULL);
d85 7
a91 5
	/* XXX not too sure why we have to send this arg */
	cvs_sendarg(root, "-N", 0);
	cvs_sendarg(root, argv[0], 0);
	cvs_senddir(root, cvs_files);
	cvs_sendreq(root, CVS_REQ_CO, NULL);
@


1.7
log
@Don't MKADMIN on cvs_file_get()
@
text
@a53 1
	CVSFILE *dir;
d72 2
a73 2
	dir = cvs_file_get(".", CF_IGNORE);
	root = CVS_DIR_ROOT(dir);
d79 1
a79 1
	cvs_senddir(root, dir);
d85 1
a85 1
	cvs_senddir(root, dir);
@


1.6
log
@Fix
@
text
@d73 1
a73 1
	dir = cvs_file_get(".", CF_IGNORE|CF_MKADMIN);
@


1.5
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@d38 1
d54 1
d73 2
a74 1
	root = cvsroot_get(".");
d80 1
a80 1
	cvs_senddir(root, ".");
d83 2
d86 1
a86 1
	cvs_senddir(root, ".");
@


1.4
log
@Don't export `cvs_root'
@
text
@d38 1
d53 1
d71 3
a73 3
	cvs_root = cvsroot_get(".");
	if (cvs_root->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_connect(cvs_root);
d76 7
a82 7
	cvs_client_sendarg(argv[0], 0);
	cvs_client_senddir(".");
	cvs_client_sendreq(CVS_REQ_XPANDMOD, NULL, 1);

	cvs_client_sendarg(argv[0], 0);
	cvs_client_senddir(".");
	cvs_client_sendreq(CVS_REQ_CO, NULL, 1);
@


1.3
log
@Pass the appropriate argument to cvs_client_connect()
@
text
@a40 4
extern struct cvsroot *cvs_root;



@


1.2
log
@* make checkout work in remote mode (almost)
@
text
@d75 1
a75 1
		cvs_client_connect();
@


1.1
log
@Initial revision
@
text
@d73 3
a75 2
	if (cvs_root->cr_method == CVS_METHOD_LOCAL) {
		return (0);
d78 7
a84 1
	cvs_client_sendreq(CVS_REQ_ARGUMENT, argv[0], 0);
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
